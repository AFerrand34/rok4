# Copyright © (2011) Institut national de l'information
#                    géographique et forestière 
# 
# Géoportail SAV <geop_services@geoportail.fr>
# 
# This software is a computer program whose purpose is to publish geographic
# data using OGC WMS and WMTS protocol.
# 
# This software is governed by the CeCILL-C license under French law and
# abiding by the rules of distribution of free software.  You can  use, 
# modify and/ or redistribute the software under the terms of the CeCILL-C
# license as circulated by CEA, CNRS and INRIA at the following URL
# "http://www.cecill.info". 
# 
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability. 
# 
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security. 
# 
# The fact that you are presently reading this means that you have had
# 
# knowledge of the CeCILL-C license and that you accept its terms.

################################################################################

=begin nd
File: Pyramid.pm

Class: BE4CEPH::Pyramid

Store all informations about a pyramid.

Using:
    (start code)
    use BE4CEPH::Pyramid;

    # 1. a new pyramid

    my $params_options = {
        #
        pyr_name_new => "ORTHO_RAW_LAMB93_D075-O",
        pyr_desc_path => "/home/ign/DESC",
        pyr_data_pool_name => "existing-ceph-pool-name",
        #
        tms_name     => "LAMB93_10cm.tms",
        tms_path     => "/home/ign/TMS",
        #
        image_width  => 16,
        image_height => 16,
        tiles_storage = TRUE,
        #
        color         => "255,255,255", # white
        #
        compression         => "raw",
        bitspersample       => 8,
        sampleformat        => "uint",
        photometric         => "rgb",
        samplesperpixel     => 3,
        interpolation       => "bicubic",
    };

    my $objPyr = BE4CEPH::Pyramid->new($params_options);

    $objPyr->writeConfPyramid(); # write pyramid's descriptor in /home/ign/DESC/ORTHO_RAW_LAMB93_D075-O.pyr

    (end code)

Attributes:
    new_pyramid - hash - Name and paths for the new pyramid
|               name - string - Pyramid's name
|               desc_path - string - Directory in which we write the pyramid's descriptor and the content list
|               data_pool - string - Ceph pool name in which we write the pyramid's data
|               content_path - string - Path to the content's list

    own_masks - boolean - If TRUE, masks generated by tools will be written in the final pyramid. If we want to export them, we have to use them in tools.
    image_width - integer - Number of tile in a pyramid's image, widthwise.
    image_height - integer - Number of tile in a pyramid's image, heightwise.
    tiles_storage - boolean - If we want to store tiles separatly. In this case, image_width and image_height are used only for work images (to treat  not to much node)

    pyrImgSpec - <COMMON::PyrImageSpec> - New pyramid's image's components
    tms - <COMMON::TileMatrixSet> - Pyramid's images will be cutted according to this TMS grid.
    nodata - <COMMON::NoData> - Informations about nodata
    levels - <BE4CEPH::Level> hash - Key is the level ID, the value is the <BE4CEPH::Level> object. Define levels present in this new ceph stored pyramid.

Limitations:

File name of pyramid must be with extension : pyr or PYR.
=cut

################################################################################

package BE4CEPH::Pyramid;

use strict;
use warnings;

use Log::Log4perl qw(:easy);
use XML::LibXML;

use Geo::OSR;

use File::Spec::Link;
use File::Basename;
use File::Spec;
use File::Path;
use File::Copy;
use Tie::File;

use Data::Dumper;

use COMMON::TileMatrixSet;
use BE4CEPH::Level;
use COMMON::NoData;
use COMMON::PyrImageSpec;
use COMMON::Pixel;
use COMMON::Forest;
use COMMON::Commands;
use COMMON::Base36;

require Exporter;
use AutoLoader qw(AUTOLOAD);

our @ISA = qw(Exporter);

our %EXPORT_TAGS = ( 'all' => [ qw() ] );
our @EXPORT_OK   = ( @{$EXPORT_TAGS{'all'}} );
our @EXPORT      = qw();

################################################################################
# Constantes
use constant TRUE  => 1;
use constant FALSE => 0;

# Constant: STRPYRTMPLT
# Define the template XML for the pyramid's descriptor.
my $STRPYRTMPLT   = <<"TPYR";
<?xml version='1.0' encoding='UTF-8'?>
<Pyramid>
    <tileMatrixSet>__TMSNAME__</tileMatrixSet>
    <format>__FORMATIMG__</format>
    <channels>__CHANNEL__</channels>
    <nodataValue>__NODATAVALUE__</nodataValue>
    <interpolation>__INTERPOLATION__</interpolation>
    <photometric>__PHOTOMETRIC__</photometric>
<!-- __LEVELS__ -->
</Pyramid>
TPYR

# Constant: DEFAULT
# Define default values for directories' names.
my %DEFAULT;

################################################################################

BEGIN {}
INIT {}
END {}

####################################################################################################
#                                        Group: Constructors                                       #
####################################################################################################

=begin nd
Constructor: new

Pyramid constructor. Bless an instance.

Parameters (list):
    params - hash - All parameters about the new pyramid, "pyramid" section of the be4ceph configuration file

See also:
    <_init>, <_load>
=cut
sub new {
    my $this = shift;
    my $params = shift;

    my $class= ref($this) || $this;
    # IMPORTANT : if modification, think to update natural documentation (just above)
    my $self = {

        new_pyramid => { 
            name          => undef,
            desc_path     => undef,
            data_pool     => undef,
            content_path  => undef,
        },

        image_width  => undef,
        image_height => undef,
        own_masks    => FALSE,

        pyrImgSpec => undef,
        tms        => undef,
        nodata     => undef,
        levels     => {},
    };

    bless($self, $class);

    # init. parameters
    if (! $self->_init($params)) {return undef;}

    # a new pyramid or from existing pyramid !
    if (! $self->_load($params)) {return undef;};
    
    return $self;   
}

=begin nd
Function: _init

We detect missing parameters and define default values for pyramids' name and path/pool.

Parameters (list):
    params - hash - All parameters about pyramid's format, pyramid section of the be4 configuration file
=cut
sub _init {
    my $self   = shift;
    my $params = shift;

    TRACE;

    if (! defined $params ) {
        ERROR ("Parameters argument required (null) !");
        return FALSE;
    }
    
    # Always mandatory :
    #   - pyr_name_new, pyr_desc_path
    #   - tms_path
    if (! exists $params->{pyr_name_new} || ! defined $params->{pyr_name_new}) {
        ERROR ("The parameter 'pyr_name_new' is required!");
        return FALSE;
    }
    $params->{pyr_name_new} =~ s/\.(pyr|PYR)$//;
    $self->{new_pyramid}->{name} = $params->{pyr_name_new};
    
    if (! exists $params->{pyr_desc_path} || ! defined $params->{pyr_desc_path}) {
        ERROR ("The parameter 'pyr_desc_path' is required!");
        return FALSE;
    }
    $self->{new_pyramid}->{desc_path} = $params->{pyr_desc_path};

    # Ceph pool informations
    
    if (! exists $params->{pyr_data_pool_name} || ! defined $params->{pyr_data_pool_name}) {
        ERROR ("The parameter 'pyr_data_pool_name' is required!");
        return FALSE;
    }
    $self->{new_pyramid}->{data_pool} = $params->{pyr_data_pool_name};
    
    if (! exists $params->{pyr_data_cluster_name} || ! defined $params->{pyr_data_cluster_name}) {
        ERROR ("The parameter 'pyr_data_cluster_name' is required!");
        return FALSE;
    }
    $self->{new_pyramid}->{cluster_name} = $params->{pyr_data_cluster_name};
    
    if (! exists $params->{pyr_data_user_name} || ! defined $params->{pyr_data_user_name}) {
        ERROR ("The parameter 'pyr_data_user_name' is required!");
        return FALSE;
    }
    $self->{new_pyramid}->{user_name} = $params->{pyr_data_user_name};
    
    if (! exists $params->{pyr_data_conf_file} || ! defined $params->{pyr_data_conf_file}) {
        ERROR ("The parameter 'pyr_data_conf_file' is required!");
        return FALSE;
    }
    $self->{new_pyramid}->{conf_file} = $params->{pyr_data_conf_file};

    # TMS informations
    
    if (! exists $params->{tms_path} || ! defined $params->{tms_path}) {
        ERROR ("The parameter 'tms_path' is required!");
        return FALSE;
    }
    $self->{tms_path} = $params->{tms_path};
            
    # For a new pyramid, are mandatory (and controlled in this class):
    #   - image_width, image_height
    
    if (! exists $params->{image_width} || ! defined $params->{image_width}) {
        ERROR ("The parameter 'image_width' is required!");
        return FALSE;
    }
    $self->{image_width} = $params->{image_width};

    if (! exists $params->{image_height} || ! defined $params->{image_height}) {
        ERROR ("The parameter 'image_height' is required!");
        return FALSE;
    }
    $self->{image_height} = $params->{image_height};

    ### We want masks in the final pyramid ?
    if ( exists $params->{export_masks} && defined $params->{export_masks} && uc($params->{export_masks}) eq "TRUE" ) {
        $self->{own_masks} = TRUE;
    }

    ### We want to store tiles separatly ?
    if ( exists $params->{tiles_storage} && defined $params->{tiles_storage} && uc($params->{tiles_storage}) eq "TRUE" ) {
        INFO("We store tiles on ceph separately");
        $self->{tiles_storage} = TRUE;
    }
    
    return TRUE;
}

=begin nd
Function: _load

We have to collect pyramid's attributes' values
    - for a new pyramid : all informations must be present in configuration.

Informations are checked, using perl classes like <COMMON::NoData>, <BE4CEPH::Level>, <COMMON::PyrImageSpec>...

Parameters (list):
    params - All parameters about a pyramid's format (new or update).
=cut
sub _load {
    my $self = shift;
    my $params = shift;

    ##### create TileMatrixSet !
    my $objTMS = COMMON::TileMatrixSet->new(File::Spec->catfile($params->{tms_path},$params->{tms_name}));

    if (! defined $objTMS) {
        ERROR ("Can not load TMS !");
        return FALSE;
    }

    $self->{tms} = $objTMS;
    DEBUG (sprintf "TMS = %s", $objTMS->exportForDebug);

    ##### create PyrImageSpec !
    my $pyrImgSpec = COMMON::PyrImageSpec->new({
        formatCode => $params->{formatCode},
        bitspersample => $params->{bitspersample},
        sampleformat => $params->{sampleformat},
        photometric => $params->{photometric},
        samplesperpixel => $params->{samplesperpixel},
        interpolation => $params->{interpolation},
        compression => $params->{compression},
        compressionoption => $params->{compressionoption},
        gamma => $params->{gamma},
    });

    if (! defined $pyrImgSpec) {
        ERROR ("Can not load specification of pyramid's images !");
        return FALSE;
    }

    $self->{pyrImgSpec} = $pyrImgSpec;
    DEBUG(sprintf "PYRIMAGESSPEC (debug export) = %s", $pyrImgSpec->exportForDebug());

    ##### create NoData !
    my $objNodata = COMMON::NoData->new({
        pixel   => $self->getPixel(),
        value   => $params->{color},
    });

    if (! defined $objNodata) {
        ERROR ("Can not load NoData !");
        return FALSE;
    }
    $self->{nodata} = $objNodata;
    
    DEBUG (sprintf "NODATA (debug export) = %s", $objNodata->exportForDebug());

    return TRUE;
}

####################################################################################################
#                              Group: Level and limits methods                                     #
####################################################################################################

=begin nd
Function: updateLevels

Determine top and bottom for the new pyramid and create Level objects.

Parameters (list):
    DSL - <DataSourceLoader> - Data sources, to determine extrem levels.
    topID - string - Optionnal, top level ID from the 'pyramid' section in the configuration file
=cut
sub updateLevels {
    my $self = shift;
    my $DSL = shift;
    my $topID = shift;
    
    # update datasources top/bottom levels !
    my ($bottomOrder,$topOrder) = $DSL->updateDataSources($self->getTileMatrixSet, $topID);
    if ($bottomOrder == -1) {
        ERROR("Cannot determine top and bottom levels, from data sources.");
        return FALSE;
    }
    
    INFO (sprintf "Bottom level order : %s, top level order : %s", $bottomOrder, $topOrder);

    if (! $self->createLevels($bottomOrder,$topOrder)) {
        ERROR("Cannot create Level objects for the new pyramid.");
        return FALSE;
    }
    
    return TRUE
}

=begin nd
Function: createLevels

Create all objects Level between the global top and the bottom levels (from data sources) for the new pyramid.

Parameters (list):
    bottomOrder - integer - Bottom level order
    topOrder - integer - Top level order
=cut
sub createLevels {
    my $self = shift;
    my $bottomOrder = shift;
    my $topOrder = shift;

    TRACE();
    
    my $objTMS = $self->getTileMatrixSet;
    if (! defined $objTMS) {
        ERROR("We need a TMS to create levels.");
        return FALSE;
    }

    my $tilesperwidth = $self->getTilesPerWidth();
    my $tilesperheight = $self->getTilesPerHeight();
    
    # Create all level between the bottom and the top
    for (my $order = $bottomOrder; $order <= $topOrder; $order++) {

        my $ID = $self->getIDfromOrder($order);
        if (! defined $ID) {
            ERROR(sprintf "Cannot identify ID for the order %s !",$order);
            return FALSE;
        }

        # params to level
        my $params = {
            id => $ID,
            order => $order,
            prefix => $self->{new_pyramid}->{name},
            size => [$tilesperwidth, $tilesperheight],
            hasMask => $self->{own_masks}
        };
        my $objLevel = BE4CEPH::Level->new($params);

        if(! defined  $objLevel) {
            ERROR("Can not create the level '$ID' !");
            return FALSE;
        }

        if (! $self->addLevel($ID, $objLevel)) {
            ERROR("Can not add the level '$ID' !");
            return FALSE;
        }
    }

    return TRUE;
}

=begin nd
Function: addLevel

Store the Level object in the Pyramid object. Return an error if the level already exists.

Parameters
    level - string - TM identifiant
    objLevel - <BE4CEPH::Level> - Level object to store
=cut
sub addLevel {
    my $self = shift;
    my $level = shift;
    my $objLevel = shift;
    
    if(! defined  $level || ! defined  $objLevel) {
        ERROR (sprintf "Level ID or Level object is undefined.");
        return FALSE;
    }
    
    if (ref ($objLevel) ne "BE4CEPH::Level") {
        ERROR (sprintf "We must have a BE4CEPH::Level object for the level $level.");
        return FALSE;
    }
    
    if (exists $self->{levels}->{$level}) {
        ERROR (sprintf "We have already a Level object for the level $level.");
        return FALSE;
    }

    $self->{levels}->{$level} = $objLevel;

    return TRUE;
}

=begin nd
Function: updateTMLimits

Compare old extrems rows/columns of the given level with the news and update values.

Parameters (list):
    level - string - Level ID whose extrems have to be updated with following bbox
    bbox - double array - [xmin,ymin,xmax,ymax], to update TM limits
=cut
sub updateTMLimits {
    my $self = shift;
    my ($level,@bbox) = @_;
    
    # We calculate extrem TILES. x -> i = column; y -> j = row
    my $tm = $self->getTileMatrixSet->getTileMatrix($level);
    
    my $iMin = $tm->xToColumn($bbox[0]);
    my $iMax = $tm->xToColumn($bbox[2]);
    my $jMin = $tm->yToRow($bbox[3]);
    my $jMax = $tm->yToRow($bbox[1]);
    
    # order in updateExtremTiles : row min, row max, col min, col max
    $self->getLevel($level)->updateExtremTiles($jMin,$jMax,$iMin,$iMax);

}

####################################################################################################
#                                  Group: Pyramid's elements writers                               #
####################################################################################################

=begin nd
Function: writeConfPyramid

Export the Pyramid object to XML format, write the pyramid's descriptor (pyr_desc_path/pyr_name_new.pyr). Use Level XML export. Levels are written in descending order, from worst to best resolution.

=cut
sub writeConfPyramid {
    my $self = shift;

    TRACE;
    
    # parsing template
    my $parser = XML::LibXML->new();

    my $doctpl = eval { $parser->parse_string($STRPYRTMPLT); };
    if (!defined($doctpl) || $@) {
        ERROR(sprintf "Can not parse template file of pyramid : %s !", $@);
        return FALSE;
    }
    my $strpyrtmplt = $doctpl->toString(0);
  
    my $descriptorFile = $self->getNewDescriptorFile();
    my $descriptorDir = dirname($descriptorFile);
  
    #
    my $tmsname = $self->getTmsName();
    $strpyrtmplt =~ s/__TMSNAME__/$tmsname/;
    #
    my $formatimg = $self->getFormatCode; # ie TIFF_RAW_INT8 !
    $strpyrtmplt  =~ s/__FORMATIMG__/$formatimg/;
    #  
    my $channel = $self->getSamplesPerPixel();
    $strpyrtmplt =~ s/__CHANNEL__/$channel/;
    #  
    my $nodata = $self->getNodataValue();
    $strpyrtmplt =~ s/__NODATAVALUE__/$nodata/;
    #  
    my $interpolation = $self->getInterpolation();
    $strpyrtmplt =~ s/__INTERPOLATION__/$interpolation/;
    #  
    my $photometric = $self->getPhotometric;
    $strpyrtmplt =~ s/__PHOTOMETRIC__/$photometric/;
    
    my @levels = sort {$a->getOrder <=> $b->getOrder} ( values %{$self->getLevels});

    for (my $i = scalar @levels -1; $i >= 0; $i--) {
        # we write levels in pyramid's descriptor from the top to the bottom
        my $levelXML = $levels[$i]->exportToXML($self);

        $strpyrtmplt =~ s/<!-- __LEVELS__ -->\n/$levelXML/;
    }
    
    $strpyrtmplt =~ s/<!-- __LEVELS__ -->\n//;
    $strpyrtmplt =~ s/^$//g;
    $strpyrtmplt =~ s/^\n$//g;
    
    if (-f $descriptorFile) {
        ERROR(sprintf "File Pyramid ('%s') exist, can not overwrite it ! ", $descriptorFile);
        return FALSE;
    }

    if (! -d $descriptorDir) {
        DEBUG (sprintf "Create the pyramid's descriptor directory '%s' !", $descriptorDir);
        eval { mkpath([$descriptorDir]); };
        if ($@) {
            ERROR(sprintf "Can not create the pyramid's descriptor directory '%s' : %s !", $descriptorDir , $@);
            return FALSE;
        }
    }
    
    if ( ! open(PYRAMID, ">", $descriptorFile) ) {
        ERROR("Cannot open $descriptorFile to write it : $!");
        return FALSE;
    }
    #
    print PYRAMID $strpyrtmplt;
    #
    close(PYRAMID);

    return TRUE;
}

=begin nd
Function: writeListPyramid

Write the pyramid list, just the pool.

Parameters (list):
    forest - <Forest> - Forest linked to the pyramid, to test if an image is present in the new pyramid.
=cut
sub writeListPyramid {
    my $self = shift;
    my $forest = shift;
    
    my $newcachelist = $self->getNewListFile;
    if (-f $newcachelist ) {
        ERROR(sprintf "New pyramid list ('%s') exist, can not overwrite it ! ", $newcachelist);
        return FALSE;
    }
    
    my $dir = dirname($newcachelist);
    if (! -d $dir) {
        DEBUG (sprintf "Create the pyramid list directory '%s' !", $dir);
        eval { mkpath([$dir]); };
        if ($@) {
            ERROR(sprintf "Can not create the pyramid list directory '%s' : %s !", $dir , $@);
            return FALSE;
        }
    }
    
    my $NEWLIST;

    if (! open $NEWLIST, ">", $newcachelist) {
        ERROR(sprintf "Cannot open new pyramid list file : %s",$newcachelist);
        return FALSE;
    }
    
    printf $NEWLIST "%s\n", $self->{new_pyramid}->{data_pool};
    printf $NEWLIST "#\n";
    close $NEWLIST;
    
    return TRUE;
}

####################################################################################################
#                                Group: Getters - Setters                                          #
####################################################################################################

###################### Outputs ######################

# Function: ownMasks
sub ownMasks {
    my $self = shift;
    return $self->{own_masks};
}

# Function: storeTiles
sub storeTiles {
    my $self = shift;
    return $self->{tiles_storage};
}

#################### New pyramid ####################


# Function: getNewName
sub getNewName {
    my $self = shift;    
    return $self->{new_pyramid}->{name};
}

# Function: getNewDescriptorFile
sub getNewDescriptorFile {
    my $self = shift;    
    return File::Spec->catfile($self->{new_pyramid}->{desc_path}, $self->{new_pyramid}->{name}.".pyr");
}

# Function: getNewDescriptorDir
sub getNewDescriptorDir {
    my $self = shift;    
    return $self->{new_pyramid}->{desc_path};
}

# Function: getNewListFile
sub getNewListFile {
    my $self = shift;
    
    if (! defined $self->{new_pyramid}->{content_path}) {
        $self->{new_pyramid}->{content_path} =
            File::Spec->catfile($self->{new_pyramid}->{desc_path}, $self->{new_pyramid}->{name}.".list");
    }
    
    return $self->{new_pyramid}->{content_path};
}


# Function: getNewDataPool
sub getNewDataPool {
    my $self = shift;    
    return $self->{new_pyramid}->{data_pool};
}

# Function: getClusterName
sub getClusterName {
    my $self = shift;    
    return $self->{new_pyramid}->{cluster_name};
}

# Function: getUserName
sub getUserName {
    my $self = shift;    
    return $self->{new_pyramid}->{user_name};
}

# Function: getConfFile
sub getConfFile {
    my $self = shift;    
    return $self->{new_pyramid}->{conf_file};
}

#################### TMS ####################

# Function: getTmsName
sub getTmsName {
    my $self = shift;
    return $self->{tms}->getName();
}

# Function: getSRS
sub getSRS {
    my $self = shift;
    return $self->{tms}->getSRS();
}

# Function: getTileMatrixSet
sub getTileMatrixSet {
    my $self = shift;
    return $self->{tms};
}

##### Pyramid's images' specifications ######

# Function: getInterpolation
sub getInterpolation {
    my $self = shift;
    return $self->{pyrImgSpec}->getInterpolation;
}

# Function: getGamma
sub getGamma {
    my $self = shift;
    return $self->{pyrImgSpec}->getGamma;
}

# Function: getCompression
sub getCompression {
    my $self = shift;
    return $self->{pyrImgSpec}->getCompression;
}

# Function: getCompressionOption
sub getCompressionOption {
    my $self = shift;
    return $self->{pyrImgSpec}->getCompressionOption;
}

# Function: getFormatCode
sub getFormatCode {
    my $self = shift;
    return $self->{pyrImgSpec}->getFormatCode;
}

# Function: getPixel
sub getPixel {
    my $self = shift;
    return $self->{pyrImgSpec}->getPixel;
}

# Function: getSamplesPerPixel
sub getSamplesPerPixel {
    my $self = shift;
    return $self->{pyrImgSpec}->getPixel->getSamplesPerPixel;
}

# Function: getPhotometric
sub getPhotometric {
    my $self = shift;
    return $self->{pyrImgSpec}->getPixel->getPhotometric;
}

# Function: getBitsPerSample
sub getBitsPerSample {
    my $self = shift;
    return $self->{pyrImgSpec}->getPixel->getBitsPerSample;
}

# Function: getSampleFormat
sub getSampleFormat {
    my $self = shift;
    return $self->{pyrImgSpec}->getPixel->getSampleFormat;
}

################## Nodata ###################

# Function: getNodata
sub getNodata {
    my $self = shift;
    return $self->{nodata};
}

# Function: getNodataValue
sub getNodataValue {
    my $self = shift;
    return $self->{nodata}->getValue;
}

################### Levels ##################

# Function: getTopOrder
sub getTopOrder {
    my $self = shift;
    
    my @levels = sort {$a->getOrder <=> $b->getOrder} ( values %{$self->getLevels});
    return $levels[-1]->getOrder;
}

# Function: getBottomOrder
sub getBottomOrder {
    my $self = shift;
    
    my @levels = sort {$a->getOrder <=> $b->getOrder} ( values %{$self->getLevels});
    return $levels[0]->getOrder;
}

=begin nd
Function: getLevel

Parameters (list):
    level - string - Level ID
=cut
sub getLevel {
    my $self = shift;
    my $level = shift;
    return $self->{levels}->{$level};
}

# Function: getLevels
sub getLevels {
    my $self = shift;
    return $self->{levels};
}

=begin nd
Function: getOrderfromID

Returns the tile matrix order from the ID.
    - 0 (bottom level, smallest resolution)
    - NumberOfTM-1 (top level, biggest resolution).

Parameters (list):
    ID - string - Level identifiant, whose order we want.
=cut
sub getOrderfromID {
    my $self = shift;
    my $ID = shift;
    return $self->getTileMatrixSet()->getOrderfromID($ID);
}

=begin nd
Function: getIDfromOrder

Returns the tile matrix ID from the ascending resolution order (integer).
    - 0 (bottom level, smallest resolution)
    - NumberOfTM-1 (top level, biggest resolution).

Parameters (list):
    order - integer - Level order, whose identifiant we want.
=cut
sub getIDfromOrder {
    my $self = shift;
    my $order = shift;
    return $self->getTileMatrixSet->getIDfromOrder($order);
}

=begin nd
Function: getCacheImageSize

Returns the pyramid's image's pixel width and height as the double list (width, height), for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getCacheImageSize {
    my $self = shift;
    my $level = shift;
    return ($self->getCacheImageWidth($level), $self->getCacheImageHeight($level));
}

=begin nd
Function: getCacheImageWidth

Returns the pyramid's image's pixel width, for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getCacheImageWidth {
    my $self = shift;
    my $level = shift;
    # width of cache image in pixel for a defined level !
    return $self->getTilesPerWidth * $self->getTileWidth($level);
}

=begin nd
Function: getCacheImageHeight

Returns the pyramid's image's pixel height, for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getCacheImageHeight {
    my $self = shift;
    my $level = shift;
    # height of cache image in pixel for a defined level !
    return $self->getTilesPerHeight * $self->getTileHeight($level);
}

=begin nd
Function: getTileWidth

Returns the tile's pixel width, for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getTileWidth {
    my $self = shift;
    my $level = shift;
    return $self->getTileMatrixSet()->getTileWidth($level);
}

=begin nd
Function: getTileHeight

Returns the tile's pixel height, for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getTileHeight {
    my $self = shift;
    my $level = shift;
    return $self->getTileMatrixSet()->getTileHeight($level);
}

# Function: getTilesPerWidth
sub getTilesPerWidth {
    my $self = shift;
    return $self->{image_width};
}

# Function: getTilesPerHeight
sub getTilesPerHeight {
    my $self = shift;
    return $self->{image_height};
}

####################################################################################################
#                                Group: Export methods                                             #
####################################################################################################

=begin nd
Function: exportForDebug

Returns all pyramid's information. Useful for debug.

Example:
    (start code)
    (end code)
=cut
sub exportForDebug {
    my $self = shift ;
    
    my $export = "";
    
    $export .= "\nObject BE4CEPH::Pyramid :\n";
    $export .= "\t New cache : \n";
    $export .= sprintf "\t\t- Name : %s\n", $self->{new_pyramid}->{name};
    $export .= sprintf "\t\t- Descriptor path : %s\n", $self->{new_pyramid}->{desc_path};
    $export .= sprintf "\t\t- Data pool : %s\n", $self->{new_pyramid}->{data_pool};
    
    $export .= "\t Image size (in pixel):\n";
    $export .= sprintf "\t\t- width : %s\n", $self->{image_width};
    $export .= sprintf "\t\t- height : %s\n", $self->{image_height};
    
    $export .= sprintf "\t Image components : %s\n", $self->{pyrImgSpec}->exportForDebug;
    
    $export .= sprintf "\t TMS : %s\n", $self->{tms}->getName;
    
    $export .= sprintf "\t Number of levels : %s\n", scalar (keys %{$self->{levels}});
    
    return $export;
}

1;
__END__

=begin nd

Group: Details

Details about pyramid's working.

Pyramid's Descriptor:

Path template: pyr_desc_path/pyr_name_new.pyr

The pyramid descriptor is written in pyr_desc_path contains global informations about the cache.
    (start code)
    <?xml version='1.0' encoding='US-ASCII'?>
    <Pyramid>
        <tileMatrixSet>LAMB93_10cm</tileMatrixSet>
        <format>TIFF_RAW_INT8</format>
        <channels>3</channels>
        <nodataValue>255,255,255</nodataValue>
        <interpolation>bicubic</interpolation>
        <photometric>rgb</photometric>
            .
        (levels)
            .
    </Pyramid>
    (end code)

And details about each level.
    (start code)
    <level>
        <tileMatrix>6</tileMatrix>
        <cephContext>
            <poolName>CEPH_POOL_NAME</poolName>
        </cephContext>
        <imagePrefix>MYPYRAMID_IMG_6</imagePrefix>
        <mask>
            <maskPrefix>MYPYRAMID_MSK_6</maskPrefix>
            <format>TIFF_ZIP_INT8</format>
        </mask>
        <tilesPerWidth>16</tilesPerWidth>
        <tilesPerHeight>16</tilesPerHeight>
        <TMSLimits>
            <minTileRow>365</minTileRow>
            <maxTileRow>368</maxTileRow>
            <minTileCol>1026</minTileCol>
            <maxTileCol>1035</maxTileCol>
        </TMSLimits>
    </level>
    (end code)

For a new pyramid, all level between top and bottom are saved into.

Cache's List:

Path template: pyr_desc_path/pyr_name_new.list

Header : index for caches' roots (used by paths, in the following list). 0 is always for the new cache.
    (start code)
    CEPH_POOL_NAME
    (end code)

A separator : #, necessary.
    (start code)
    #
    (end code)

Images' list : just object names
    (start code)
    MYPYRAMID_IMG_6_125_65
    MYPYRAMID_IMG_7_1625_845
    .
    .
    (end code)

The new cache's list is written by writeCachePyramid. The file is completed by Process, to add generated images.

=cut
