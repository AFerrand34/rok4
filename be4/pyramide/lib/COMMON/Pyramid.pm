# Copyright © (2011) Institut national de l'information
#                    géographique et forestière 
# 
# Géoportail SAV <geop_services@geoportail.fr>
# 
# This software is a computer program whose purpose is to publish geographic
# data using OGC WMS and WMTS protocol.
# 
# This software is governed by the CeCILL-C license under French law and
# abiding by the rules of distribution of free software.  You can  use, 
# modify and/ or redistribute the software under the terms of the CeCILL-C
# license as circulated by CEA, CNRS and INRIA at the following URL
# "http://www.cecill.info". 
# 
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability. 
# 
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security. 
# 
# The fact that you are presently reading this means that you have had
# 
# knowledge of the CeCILL-C license and that you accept its terms.

################################################################################

=begin nd
File: Pyramid.pm

Class: COMMON::Pyramid

Store all informations about a pyramid.

Using:
    (start code)
    use COMMON::Pyramid;

    (end code)

Attributes:
    name - string - Pyramid's name
    desc_path - string - Directory in which we write the pyramid's descriptor
    data_path - string - Directory in which we write the pyramid's data
    content_path - string - Path to the content's list

    own_masks - boolean - If TRUE, masks generated by tools will be written in the final pyramid. If we want to export them, we have to use them in tools.
    image_width - integer - Number of tile in an pyramid's image, widthwise.
    image_height - integer - Number of tile in an pyramid's image, heightwise.

    pyrImgSpec - <PyrImageSpec> - Pyramid's image's components
    tms - <TileMatrixSet> - Pyramid's images will be cutted according to this TMS grid.
    nodata - string - Nodata color
    levels - <Level> hash - Key is the level ID, the value is the <Level> object. Define levels present in the pyramid.

    dir_depth - integer - Number of subdirectories from the level root to the image : depth = 2 => /.../LevelID/SUB1/SUB2/IMG.tif
    dir_image - string - Name of images' directory
    dir_mask - string - Name of masks' directory

=cut

################################################################################

package COMMON::Pyramid;

use strict;
use warnings;

use Log::Log4perl qw(:easy);
use XML::LibXML;

use File::Spec::Link;
use File::Basename;
use File::Spec;
use File::Path;
use File::Copy;
use Tie::File;

use Data::Dumper;

use COMMON::Level;
use COMMON::NoData;
use COMMON::PyrImageSpec;

require Exporter;
use AutoLoader qw(AUTOLOAD);

our @ISA = qw(Exporter);

our %EXPORT_TAGS = ( 'all' => [ qw() ] );
our @EXPORT_OK = ( @{$EXPORT_TAGS{'all'}} );
our @EXPORT = qw();

################################################################################
# Constantes
use constant TRUE  => 1;
use constant FALSE => 0;

################################################################################

BEGIN {}
INIT {}
END {}

####################################################################################################
#                                        Group: Constructors                                       #
####################################################################################################

=begin nd
Constructor: new

Pyramid constructor. Bless an instance.

Parameters (list):
    type - string - DESCRIPTOR or VALUES
    params - hash - All parameters about the new pyramid, "pyramid" section of the be4 configuration file
See also:
    <_init>, <_load>
=cut
sub new {
    my $class = shift;
    my $type = shift;
    my $params = shift;
    my $ancestor = shift;

    $class = ref($class) || $class;

    # IMPORTANT : if modification, think to update natural documentation (just above)

    my $this = {
        type => undef,

        name => undef,
        desc_path => undef,
        content_path  => undef,

        # OUT
        image_width  => undef,
        image_height => undef,
        own_masks => FALSE,

        pyrImgSpec => undef,
        tms => undef,
        nodata => undef,
        levels => {},

        storage_type => undef,
        # Pyramide FICHIER
        data_path => undef,
        dir_depth => undef,

        # Pyramide S3
        data_bucket => undef,

        # Pyramide CEPH
        data_pool => undef,
        tiles_storage => FALSE
    };

    bless($this, $class);

    if ($type eq "DESCRIPTOR") {
        # Le paramètre est le chemin du descripteur de pyramide, on en tire 'name' et 'desc_path'
        if (! -f $params) {
            ERROR ("XML file does not exist: $params !");
            return FALSE;
        }

        # Cette pyramide est donc en lecture, on ne tient pas compte d'un éventuel ancêtre
        $this->{type} = "READ";
        $ancestor = undef;

        $this->{name} = File::Basename::basename($params);
        $this->{name} =~ s/\.pyr$//i;
        $this->{desc_path} = File::Basename::dirname($params);

        # On remplit params avec les paramètres issus du parsage du XML
        $params = {};
        $params->{desc_path} = $this->{desc_path};
        $params->{name} = $this->{name};
        if (! $this->_readDescriptor($params)) {
            ERROR ("The parameter 'name' is required !");
            return undef;
        }

    } else {
        # On crée une pyramide à partir de ses caractéristiques
        # Cette pyramide est donc une nouvelle pyramide, à écrire
        $this->{type} = "WRITE";

        # Pyramid pyr_name_new, desc path
        if (! exists $params->{pyr_name_new} || ! defined $params->{pyr_name_new}) {
            ERROR ("The parameter 'pyr_name_new' is required!");
            return undef;
        }
        $this->{name} = $params->{pyr_name_new};
        $this->{name} =~ s/\.(pyr|PYR)$//;

        if (! exists $params->{pyr_desc_path} || ! defined $params->{pyr_desc_path}) {
            ERROR ("The parameter 'pyr_desc_path' is required!");
            return undef;
        }
        $this->{desc_path} = $params->{pyr_desc_path};

        if (exists $params->{data_path} && defined $params->{pyr_data_path}) {

            #### CAS D'UNE PYRAMIDE FICHIER
            $this->{storage_type} = "FILE";
            $this->{data_path} = $params->{pyr_data_path};

            # dir_depth
            if (! exists $params->{dir_depth} || ! defined $params->{dir_depth}) {
                ERROR ("The parameter 'dir_depth' is required!");
                return undef;
            }
            $this->{dir_depth} = $params->{dir_depth};
        }

        elsif (exists $params->{pyr_data_bucket_name} && defined $params->{pyr_data_bucket_name}) {

            #### CAS D'UNE PYRAMIDE S3
            $this->{storage_type} = "S3";
            $this->{data_bucket} = $params->{pyr_data_bucket_name};

        }

        elsif (exists $params->{pyr_data_pool_name} && defined $params->{pyr_data_pool_name}) {

            #### CAS D'UNE PYRAMIDE CEPH
            $this->{storage_type} = "CEPH";
            $this->{data_pool} = $params->{pyr_data_pool_name};

            if (exists $params->{tiles_storage} && defined $params->{tiles_storage} && uc($params->{tiles_storage}) eq "TRUE") {
                $this->{tiles_storage} = $params->{tiles_storage};
            }

        }

        else {
            ERROR("No storage provided for the new pyramid");
            return undef;
        }

    }

    if ( ! $this->_load($params,$ancestor) ) {return undef;}

    return $this;
}

=begin nd
Function: _load
=cut
sub _load {
    my $this   = shift;
    my $params = shift;
    my $ancestor = shift;

    if (! defined $params ) {
        ERROR ("Parameters argument required (null) !");
        return FALSE;
    }

    if (defined $ancestor) {
        INFO("We have an ancestor, all parameters are picked from this pyramid");
        # les valeurs sont récupérées de l'ancêtre pour s'assurer la cohérence
        $this->{tms} = $ancestor->getTileMatrixSet()->getName();
        $this->{image_width} = $ancestor->getTilesPerWidth();
        $this->{image_height} = $ancestor->getTilesPerHeight();
        $this->{pyrImgSpec} = $ancestor->getImageSpec();
        $this->{nodata} = $ancestor->getNodata();
    } else {
        # TMS
        if (! exists $params->{tms_name} || ! defined $params->{tms_name}) {
            ERROR ("The parameter 'tms_name' is required!");
            return FALSE;
        }
        # On chargera l'objet TMS plus tard on ne mémorise pour le moment que son nom.
        $this->{tms} = $params->{tms_name};
        $this->{tms} =~ s/\.TMS$//i;
        
        # image_width
        if (! exists $params->{image_width} || ! defined $params->{image_width}) {
            ERROR ("The parameter 'image_width' is required!");
            return FALSE;
        }
        $this->{image_width} = $params->{image_width};

        # image_height
        if (! exists $params->{image_height} || ! defined $params->{image_height}) {
            ERROR ("The parameter 'image_height' is required!");
            return FALSE;
        }
        $this->{image_height} = $params->{image_height};

        # PyrImageSpec
        my $pyrImgSpec = COMMON::PyrImageSpec->new($params);

        if (! defined $pyrImgSpec) {
            ERROR ("Can not load specification of pyramid's images !");
            return FALSE;
        }

        $this->{pyrImgSpec} = $pyrImgSpec;

        # NoData
        if (! exists $params->{color} || ! defined $params->{color}) {
            ERROR ("The parameter 'color' is required!");
            return FALSE;
        }
        ##### create NoData !
        my $objNodata = COMMON::NoData->new({
            pixel   => $this->{pyrImgSpec}->getPixel(),
            value   => $params->{color},
        });

        if (! defined $objNodata) {
            ERROR ("Can not load NoData !");
            return FALSE;
        }
        $this->{nodata} = $objNodata;
    }

    # We want masks in the final pyramid ?
    if ( exists $params->{export_masks} && defined $params->{export_masks} && uc($params->{export_masks}) eq "TRUE" ) {
        $this->{own_masks} = TRUE;
    }

    return TRUE;
}


=begin nd
Function: _readDescriptor
=cut
sub _readDescriptor {
    my $this   = shift;
    my $params = shift;

    my $pyrDescFile = File::Spec->catfile($this->{desc_path},$this->{name}.".pyr");

    # read xml pyramid
    my $parser  = XML::LibXML->new();
    my $xmltree =  eval { $parser->parse_file($pyrDescFile); };

    if (! defined ($xmltree) || $@) {
        ERROR (sprintf "Can not read the XML file $pyrDescFile : %s !", $@);
        return FALSE;
    }

    my $root = $xmltree->getDocumentElement;

    # read tag value of nodata value, photometric and interpolation (not obligatory)

    # NODATA
    my $tagnodata = $root->findnodes('nodataValue')->to_literal;
    if ($tagnodata eq '') {
        ERROR (sprintf "Can not extract 'nodata' from the XML file $pyrDescFile !");
        return FALSE;
    }
    $params->{color} = $tagnodata;
    
    # PHOTOMETRIC
    my $tagphotometric = $root->findnodes('photometric')->to_literal;
    if ($tagphotometric eq '') {
        ERROR (sprintf "Can not extract 'photometric' from the XML file $pyrDescFile !");
        return FALSE;
    }
    $params->{photometric} = $tagphotometric;

    # INTERPOLATION    
    my $taginterpolation = $root->findnodes('interpolation')->to_literal;
    if ($taginterpolation eq '') {
        ERROR (sprintf "Can not extract 'interpolation' from the XML file $pyrDescFile !");
        return FALSE;
    }
    $params->{interpolation} = $taginterpolation;

    # Read tag value of tileMatrixSet, format and channel, MANDATORY

    # TMS
    my $tagtmsname = $root->findnodes('tileMatrixSet')->to_literal;
    if ($tagtmsname eq '') {
        ERROR (sprintf "Can not extract 'tileMatrixSet' from the XML file $pyrDescFile !");
        return FALSE;
    }
    $params->{tms_name} = $tagtmsname;

    # FORMAT
    my $tagformat = $root->findnodes('format')->to_literal;
    if ($tagformat eq '') {
        ERROR (sprintf "Can not extract 'format' in the XML file $pyrDescFile !");
        return FALSE;
    }

    my ($comp, $sf, $bps) = COMMON::PyrImageSpec::decodeFormat($tagformat);
    if (! defined $comp) {
        ERROR (sprintf "Can not decode the pyramid format");
        return FALSE;
    }

    $params->{sampleformat} = $sf;
    $params->{compression} = $comp;
    $params->{bitspersample} = $bps;

    # SAMPLESPERPIXEL  
    my $tagsamplesperpixel = $root->findnodes('channels')->to_literal;
    if ($tagsamplesperpixel eq '') {
        ERROR (sprintf "Can not extract 'channels' in the XML file $pyrDescFile !");
        return FALSE;
    } 
    $params->{samplesperpixel} = $tagsamplesperpixel;

    # load pyramid level
    my @levels = $root->getElementsByTagName('level');

    my $oneLevelId;
    my $storageType = undef;
    foreach my $v (@levels) {

        my $tagtm = $v->findvalue('tileMatrix');

        my $objLevel = COMMON::Level->new("XML", $v, $this->{desc_path});
        if (! defined $objLevel) {
            ERROR(sprintf "Can not load the pyramid level : '%s'", $tagtm);
            return FALSE;
        }

        # On vérifie que tous les niveaux ont le même type de stockage
        if(defined $storageType && $objLevel->getStorageType() ne $storageType) {
            ERROR(sprintf "All level have to own the same storage type (%s -> %s != %s)", $tagtm, $objLevel->getStorageType(), $storageType);
            return FALSE;
        }
        $storageType = $objLevel->getStorageType();

        $this->{levels}->{$tagtm} = $objLevel;

        $oneLevelId = $tagtm;

        # same for each level
    }

    if (defined $oneLevelId) {
        $params->{image_width}  = $this->{levels}->{$oneLevelId}->getImageWidth();
        $params->{image_height} = $this->{levels}->{$oneLevelId}->getImageHeight();

        if ($this->{levels}->{$oneLevelId}->ownMasks()) {
            $params->{export_masks} = "TRUE";
        }
        $this->{storage_type} = $storageType;
    } else {
        # On a aucun niveau dans la pyramide à charger, il va donc nous manquer des informations : on sort en erreur
        ERROR("No level in the pyramid's descriptor $pyrDescFile");
        return FALSE;
    }

    return TRUE;
}

####################################################################################################
#                                        Group: Update pyramid                                     #
####################################################################################################

sub bindTileMatrixSet {
    my $this = shift;
    my $tmsPath = shift;

    # 1 : Créer l'objet TileMatrixSet
    my $tmsFile = File::Spec->catdir($tmsPath, $this->{tms}.".tms");
    $this->{tms} = COMMON::TileMatrixSet->new($tmsFile);
    if (! defined $this->{tms}) {
        ERROR("Cannot create a TileMatrixSet object from the file $tmsFile");
        return FALSE;
    }

    # 2 : Lier le TileMatrix à chaque niveau de la pyramide
    while (my ($id, $level) = each(%{$this->{levels}}) ) {
        if (! $level->bindTileMatrix($this->{tms})) {
            ERROR("Cannot bind a TileMatrix to pyramid's level $id");
            return FALSE;
        }
    }

    return TRUE;
}

sub addLevel {
    my $this = shift;
    my $level = shift;
    my $ancestor = shift;

    if ($this->{type} eq "READ") {
        ERROR("Cannot add level to 'read' pyramid");
        return FALSE;        
    }

    if (exists $this->{levels}->{$level}) {
        ERROR("Cannot add level $level in pyramid : already exists");
        return FALSE;
    }

    my $levelParams = {};
    if (defined $this->{data_path}) {
        # On doit ajouter un niveau stockage fichier
        $levelParams = {
            id => $level,
            tm => $this->{tms}->getTileMatrix($level),
            size => [$this->{image_width}, $this->{image_height}],

            dir_image => File::Spec->catdir($this->{desc_path}, $this->{name}, $this->{dir_image}, $level),
            dir_depth => $this->{dir_depth}
        };

        if ($this->{own_masks}) {
            $levelParams->{dir_mask} = File::Spec->catdir($this->{desc_path}, $this->{name}, $this->{dir_mask}, $level);
        }
    }
    elsif (defined $this->{data_pool}) {
        # On doit ajouter un niveau stockage ceph
        $levelParams = {
            id => $level,
            tm => $this->{tms}->getTileMatrix($level),
            size => [$this->{image_width}, $this->{image_height}],

            prefix => $this->{name},
            pool_name => $this->{data_pool}
        };

        if ($this->{own_masks}) {
            $levelParams->{hasMask} = TRUE;
        }
    }
    elsif (defined $this->{data_bucket}) {
        # On doit ajouter un niveau stockage s3
        $levelParams = {
            id => $level,
            tm => $this->{tms}->getTileMatrix($level),
            size => [$this->{image_width}, $this->{image_height}],

            prefix => $this->{name},
            bucket_name => $this->{data_bucket}
        };

        if ($this->{own_masks}) {
            $levelParams->{hasMask} = TRUE;
        }
    }

    # Niveau ancêtre, potentiellement non défini, pour en reprendre les limites
    if (defined $ancestor) {
        my $ancestorLevel = $ancestor->getLevel($ID);
        if (defined $ancestorLevel) {
            my ($rowMin,$rowMax,$colMin,$colMax) = $ancestorLevel->getLimits();
            $levelParams->{limits} = [$rowMin,$rowMax,$colMin,$colMax];
        }
    }

    $this->{levels}->{$level} = COMMON::Level->new("VALUES", $levelParams, $this->{desc_path});

    if (! defined $this->{levels}->{$level}) {
        ERROR("Cannot create a Level object for level $level");
        return FALSE;
    }

    return TRUE;
}

sub updateTMLimits {
    my $this = shift;
    my ($level,@bbox) = @_;
        
    $this->{levels}->{$level}->updateLimitsFromBbox(@bbox);
}

####################################################################################################
#                                      Group: Pyramids comparison                                  #
####################################################################################################

=begin nd
Function: checkConsistency

We control values, in order to have the same as the final pyramid.

Compatibility = it's possible to convert (different compression or samples per pixel).

Equals = all format's parameters are the same (not the content).

Return 0 if pyramids is not consistent, 1 if compatibility but not equals, 2 if equals

Parameters (list):
    other - <COMMON::Pyramid> - Pyramid to compare
=cut
sub checkCompatibility {
    my $this = shift;
    my $other = shift;
    my $strict = shift;

    if ($this->getTilesPerWidth() != $other->getTilesPerWidth()) {
        return 0;
    }
    if ($this->getTilesPerHeight() != $other->getTilesPerHeight()) {
        return 0;
    }
    if ($this->getDirDepth() != $other->getDirDepth()) {
        return 0;
    }

    if ($this->getTileMatrixSet()->getName() ne $other->getTileMatrixSet()->getName()) {
        return 0;
    }

    if ($this->getImageSpec()->getPixel()->getSampleFormat() ne $other->getImageSpec()->getPixel()->getSampleFormat()) {
        return 0;
    }
    if ($this->getImageSpec()->getPixel()->getBitsPerSample() ne $other->getImageSpec()->getPixel()->getBitsPerSample()) {
        return 0;
    }

    # Photometric; samplesperpixel et compression peuvent être différent, on garde la compatibilité
    if ($this->getImageSpec()->getPixel()->getPhotometric() ne $other->getImageSpec()->getPixel()->getPhotometric()) {
        return 1;
    }
    if ($this->getImageSpec()->getPixel()->getSamplesPerPixel() ne $other->getImageSpec()->getPixel()->getSamplesPerPixel()) {
        return 1;
    }
    if ($this->getImageSpec()->getCompression() ne $other->getImageSpec()->getCompression()) {
        return 1;
    }

    return 2;
}

####################################################################################################
#                                      Group: Write  functions                                     #
####################################################################################################

sub writeDescriptor {
    my $this = shift;

    if ($this->{type} eq "READ") {
        ERROR("Cannot write descriptor of 'read' pyramid");
        return FALSE;        
    }

    my $descPath = File::Spec->catdir($this->{desc_path}, $this->{name}.".pyr");

    if (-f $descPath) {
        ERROR("New pyramid descriptor ('$descPath') exist, can not overwrite it !");
        return FALSE;
    }

    if (! open FILE, ">", $descPath ){
        ERROR(sprintf "Cannot open the pyramid descriptor %s to write",$descPath);
        return FALSE;
    }

    my $string = "<?xml version='1.0' encoding='UTF-8'?>\n";
    $string .= "<Pyramid>\n";
    $string .= sprintf "    <tileMatrixSet>%s</tileMatrixSet>\n", $this->{tms}->getName();
    $string .= sprintf "    <format>%s</format>\n", $this->{pyrImgSpec}->getFormatCode();
    $string .= sprintf "    <channels>%s</channels>\n", $this->{pyrImgSpec}->getPixel()->getSamplesPerPixel();
    $string .= sprintf "    <nodataValue>%s</nodataValue>\n", $this->{nodata}->getValue();
    $string .= sprintf "    <interpolation>%s</interpolation>\n", $this->{pyrImgSpec}->getInterpolation();
    $string .= sprintf "    <photometric>%s</photometric>\n", $this->{pyrImgSpec}->getPixel()->getPhotometric();


    my @orderedLevels = sort {$a->getOrder <=> $b->getOrder} ( values %{$this->{levels}});

    for (my $i = scalar @orderedLevels - 1; $i >= 0; $i--) {
        # we write levels in pyramid's descriptor from the top to the bottom
        $string .= $orderedLevels[$i]->exportToXML();
    }

    $string .= "</Pyramid>";

    print FILE $string;

    close(FILE);

    return TRUE
}

sub writeList {
    my $this = shift;
    my $forest = shift;
    my $ancestor = shift;
    my $updateMode = shift;

    if ($this->{type} eq "READ") {
        ERROR("Cannot write list of 'read' pyramid");
        return FALSE;        
    }

    if (! defined $forest || ref ($forest) ne "COMMON::Forest" ) {
        ERROR(sprintf "We need a COMMON::Forest to write pyramid list ! ");
        return FALSE;
    }

    if (defined $ancestor && ref ($ancestor) ne "COMMON::Pyramid" ) {
        ERROR(sprintf "Ancestor, if provided, have to be a COMMON::Pyramid ! ");
        return FALSE;
    }

    my $newListPath = $this->getListFile();

    if (-f $newListPath ) {
        ERROR(sprintf "New pyramid list ('%s') exist, can not overwrite it ! ", $newListPath);
        return FALSE;
    }

    my $dir = File::Basename::dirname($newListPath);
    if (! -d $dir) {
        eval { mkpath([$dir]); };
        if ($@) {
            ERROR(sprintf "Can not create the pyramid list directory '%s' : %s !", $dir , $@);
            return FALSE;
        }
    }
    
    my $NEWLIST;

    if (! open $NEWLIST, ">", $newListPath) {
        ERROR(sprintf "Cannot open new pyramid list file (write) : %s",$newListPath);
        return FALSE;
    }
    
    if (! defined $ancestor) {
        # Pas d'ancêtre, on doit juste écrire l'en tête : le dossier propre à cette pyramide ou le nom du conteneur objet
        
        if (defined $this->{data_path}) {
            printf $NEWLIST "0=%s\n", $this->getDataDir();
        }
        elsif (defined $this->{data_pool}) {
            printf $NEWLIST "0=%s\n", $this->{data_pool};
        }
        elsif (defined $this->{data_bucket}) {
            printf $NEWLIST "0=%s\n", $this->{data_bucket};
        }

        printf $NEWLIST "#\n";
        close $NEWLIST;

        return TRUE
    }

    # On a un ancêtre, il va falloir en référencer toutes les dalles
    # On va vérifier la compatibilité du stockage de l'ancêtre avec celui de la nouvelle pyramide et le mode de mise à jour

    if (! defined $updateMode || $updateMode eq "") {
        ERROR("Update mode have to be provided with an ancestor");
        return FALSE;
    }

    my $newStorageType = $this->getStorageType();

    # Le hash est de la forme : ancestor storage => new storage => update mode possible = 1
    my $allowedUpdateModes = {
        "FILE" => {
            "FILE" => {
                "slink" => 1,
                "hlink" => 1,
                "copy" => 1,
                "inject" => 1
            }
        },
        "CEPH" => {
            "CEPH" => {
            }
        },
        "S3" => {
            "S3" => {
            }
        },
    };

    my $ancestorStorageType = $ancestor->getStorageType();

    if (! exists $allowedUpdateModes->{$ancestorStorageType}->{$newStorageType}->{updateMode})
        ERROR("Update mode '$updateMode' is not allowed for storages $ancestorStorageType -> $newStorageType");
        return FALSE;
    }

    # On va lire la liste de l'ancêtre
    my $ancestorListPath = $ancestor->getListFile();
    my $OLDLIST;
    
    if (! open $OLDLIST, "<", $ancestorListPath) {
        ERROR("Cannot open old pyramid list file (read) : $ancestorListPath");
        return FALSE;
    }
    
    my %newCacheRoots;
    my %newCacheRootsUse;
    while( my $line = <$OLDLIST> ) {
        chomp $line;
        if ($line eq "#") {
            # separator between caches' roots and images
            last;
        }
        
        $line =~ s/\s+//g; # we remove all spaces
        my @Root = split(/=/,$line,-1);
        
        if (scalar @Root != 2) {
            ERROR(sprintf "Wrong formatted pyramid list (root definition) : %s",$line);
            return FALSE;
        }
        
        # ID 0 is kept for the new pyramid root, all ID are incremented
        $newCacheRoots{$Root[0]+1} = $Root[1];
        $newCacheRootsUse{$Root[0]+1} = 0;
    }
    
    while( my $line = <$OLDLIST> ) {
        chomp $line;
        
        # Une ligne du fichier c'est
        # Cas fichier : 0/IMAGE/15/AB/CD/EF.tif
        # Cas objet : 0/PYRAMID_IMG_15_15656_5423
        my @parts = split("/", $line);
        # La première partie est donc toujours l'index de la racine, qui est soit un dossier soit un conteneur d'objet
        my $rootIndex = shift(@parts);

        my $dataType = undef;
        my $level = undef;
        # Selon le type de stockage, on identifie le type de donnée, image ou masque
        if ($this->{storage_type} eq "FILE") {
            # Dans le cas d'un stockage fichier, le premier élément du chemin est maintenant le type de donnée
            $dataType = shift(@parts);
            # et le suivant est le niveau
            $level = shift(@parts);
        }
        else {
            # Dans le cas d'un stockage objet, on a un nom d'objet de la forme BLA_BLA_DATATYPE_LEVEL_COL_ROW
            # DATATYPE vaut MSK ou IMG
            my @p = split("_", join("", @parts));
            $level = $p[-3];
            $dataType = $p[-4];
        }

        if (! $self->ownMasks() && ($dataType = "MSK" || $dataType = "MASK")) {
            # On ne veut pas des masques dans la pyramide finale, donc on ne lie pas ceux de l'ancienne pyramide
            next;
        }

        if (! exists $this->{levels}->{$level}) {
            # La dalle appartient à un niveau qui n'est pas voulu dans la nouvelle pyramide
            next;
        }
        
        my ($x,$y) = $this->{levels}->{$level}->getFromSlabPath($line);
        
        if (! $forest->containsNode($level,$x,$y)) {
            # This image is not in the forest, it won't be modified by this generation.
            # We add it now to the list (real file path)
            my $newTileFileName = File::Spec->catdir(@directories);
            if ($self->getUpdateMode() eq 'hlink' || $self->getUpdateMode() eq 'copy' || $self->getUpdateMode() eq 'inject') {
                $newTileFileName =~ s/^[0-9]+\//0\//;
            }
            printf $NEWLISTTMP "%s\n", $newTileFileName;
            # Root is used : we incremente its counter
            $newCacheRootsUse{$directories[0]}++;
        }
        
        if ($self->getUpdateMode() ne 'inject') {
            # In injection case, we don't create a new pyramid version : no link, no copy, nothing to do
        
            # We replace root ID with the root path, to obtain a real path.
            if (! exists $newCacheRoots{$directories[0]}) {
                ERROR(sprintf "Old pyramid list uses an undefined root ID : %s",$directories[0]);
                return FALSE;
            }
            $directories[0] = $newCacheRoots{$directories[0]};
            $oldtile = File::Spec->catdir(@directories);
            
            # We remove the root to replace it by the new pyramid root
            shift @directories;
            my $newtile = File::Spec->catdir($newcachepyramid,@directories);

            #create folders
            my $dir = dirname($newtile);
            
            if (! -d $dir) {
                eval { mkpath([$dir]); };
                if ($@) {
                    ERROR(sprintf "Can not create the pyramid directory '%s' : %s !",$dir, $@);
                    return FALSE;
                }
            }

            if (! -f $oldtile || -l $oldtile) {
                ERROR(sprintf "File path in the pyramid list does not exist or is a link : %s",$oldtile);
                return FALSE;
            }
            
            my $reloldtile = File::Spec->abs2rel($oldtile, $dir);

            if ($self->getUpdateMode() eq 'slink') {
                DEBUG(sprintf "Creating symbolic link from %s to %s", $oldtile, $newtile);
                my $result = eval { symlink ($reloldtile, $newtile); };
                if (! $result) {
                    ERROR (sprintf "The tile '%s' can not be soft linked to '%s' (%s)",$reloldtile,$newtile,$!);
                    return FALSE;
                }
            } elsif ($self->getUpdateMode() eq 'hlink') {
                DEBUG(sprintf "Creating hard link from %s to %s", $oldtile, $newtile);
                my $result = eval { link ($oldtile, $newtile); };
                if (! $result) {
                    ERROR (sprintf "The tile '%s' can not be hard linked to '%s' (%s)",$oldtile,$newtile,$!);
                    return FALSE;
                }
            } elsif ($self->getUpdateMode() eq 'copy') {
                DEBUG(sprintf "Copying tile from %s to %s", $newtile, $oldtile);
                my $result = eval { copy($oldtile, $newtile); };
                if (! $result) {
                    ERROR (sprintf "The tile '%s' can not be copied to '%s' (%s)",$oldtile,$newtile,$!);
                    return FALSE;
                }
            } else {
                ERROR (sprintf "Unknown update mode : '%s'",$self->getUpdateMode());
                return FALSE;
            }
        }
        
    }
    
    close $OLDLIST;








    my $newcachepyramid = $self->getNewDataDir;
    
    my $newcachelisttmp = File::Spec->catfile($path_temp,$self->getNewName(),$self->getNewName()."_tmp.list");;
    
    my $newcachelist = $self->getNewListFile;
    if (-f $newcachelist && ($self->isNewPyramid() || $self->getUpdateMode() ne "inject")) {
        ERROR(sprintf "New pyramid list ('%s') exist, can not overwrite it ! ", $newcachelist);
        return FALSE;
    }
    
    my $dir = dirname($newcachelist);
    if (! -d $dir) {
        DEBUG (sprintf "Create the pyramid list directory '%s' !", $dir);
        eval { mkpath([$dir]); };
        if ($@) {
            ERROR(sprintf "Can not create the pyramid list directory '%s' : %s !", $dir , $@);
            return FALSE;
        }
    }
    
    my $dirtmp = dirname($newcachelisttmp);
    if (! -d $dir) {
        DEBUG (sprintf "Create the temporary pyramid list directory '%s' !", $dirtmp);
        eval { mkpath([$dirtmp]); };
        if ($@) {
            ERROR(sprintf "Can not create the temporary pyramid list directory '%s' : %s !", $dirtmp , $@);
            return FALSE;
        }
    }
    
    my $NEWLISTTMP;

    if (! open $NEWLISTTMP, ">", $newcachelisttmp) {
        ERROR(sprintf "Cannot open temporary new pyramid list file : %s",$newcachelisttmp);
        return FALSE;
    }
    
    printf $NEWLISTTMP "#\n";
    
    # Hash to bind ID and root directory
    my %newCacheRoots;
    
    # Hash to count root's uses (to remove useless roots)
    my %newCacheRootsUse;
    
    # search and create link for only new pyramid tile
    if (! $self->isNewPyramid) {
        

    }
    
    close $NEWLISTTMP;
    
    # Now, we can write binding between ID and root, testing counter.
    # We write at the top of the list file, caches' roots, using Tie library
    my @NEWLISTTMP;
    if (! tie @NEWLISTTMP, 'Tie::File', $newcachelisttmp) {
        ERROR(sprintf "Cannot write the header of temporary new pyramid list file : %s",$newcachelisttmp);
        return FALSE;
    }
    
    if (! $self->isNewPyramid && $self->getUpdateMode() eq 'slink') {
        while( my ($rootID,$root) = each(%newCacheRoots) ) {
            if ($newCacheRootsUse{$rootID} > 0) {
                # Used roots are written in the header
                
                INFO (sprintf "%s is used %d times", $root, $newCacheRootsUse{$rootID});
                
                unshift @NEWLISTTMP,(sprintf "%s=%s",$rootID,$root);
            } else {
                INFO (sprintf "The old pyramid '%s' is no longer used.", $root)
            }
        }
    }
    
    # Root of the new pyramid (first position)
    unshift @NEWLISTTMP,"0=$newcachepyramid\n";
    
    untie @NEWLISTTMP;
    
    # On copie notre descripteur de pyramide temporaire au bon endroit
    my $return = `mv $newcachelisttmp $newcachelist`;
    if ($? != 0) {
        ERROR("Cannot move $newcachelisttmp -> $newcachelist : $!");
        return FALSE;
    }    

    return FALSE;
}

####################################################################################################
#                                Group: Common getters                                             #
####################################################################################################

# Function: storeTiles
sub ownMasks {
    my $this = shift;
    return $this->{own_masks};
}

# Function: storeTiles
sub storeTiles {
    my $this = shift;
    return $this->{tiles_storage};
}

# Function: getName
sub getName {
    my $this = shift;    
    return $this->{name};
}

# Function: getDescriptorFile
sub getDescriptorFile {
    my $this = shift;    
    return File::Spec->catfile($this->{desc_path}, $this->{name}.".pyr");
}

# Function: getDescriptorDir
sub getDescriptorDir {
    my $this = shift;    
    return $this->{desc_path};
}

# Function: getListFile
sub getListFile {
    my $this = shift;
    
    if (! defined $this->{content_path}) {
        $this->{content_path} = File::Spec->catfile($this->{desc_path}, $this->{name}.".list");
    }
    
    return $this->{content_path};
}


# Function: getTileMatrixSet
sub getTileMatrixSet {
    my $this = shift;
    return $this->{tms};
}

# Function: getImageSpec
sub getImageSpec {
    my $this = shift;
    return $this->{pyrImgSpec};
}

# Function: getNodata
sub getNodata {
    my $this = shift;
    return $this->{nodata};
}

=begin nd
Function: getSlabPath

Returns the theoric slab path, undef if the level is not present in the pyramid

Parameters (list):
    type - string - IMGAGE, MASK
    level - string - Level ID
    col - integer - Slab column
    row - integer - Slab row
=cut
sub getSlabPath {
    my $this = shift;
    my $type = shift;
    my $level = shift;
    my $col = shift;
    my $row = shift;

    if (! exists $this->{levels}->{$level}) {
        return undef;
    }

    return $this->{levels}->{$level}->getSlabPath($type, $col, $row);
}

# Function: getTilesPerWidth
sub getTilesPerWidth {
    my $this = shift;
    return $this->{image_width};
}

# Function: getTilesPerHeight
sub getTilesPerHeight {
    my $this = shift;
    return $this->{image_height};
}

=begin nd
Function: getCacheImageSize

Returns the pyramid's image's pixel width and height as the double list (width, height), for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getCacheImageSize {
    my $this = shift;
    my $level = shift;
    return ($this->getCacheImageWidth($level), $this->getCacheImageHeight($level));
}

=begin nd
Function: getCacheImageWidth

Returns the pyramid's image's pixel width, for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getCacheImageWidth {
    my $this = shift;
    my $level = shift;

    return $this->{image_width} * $this->{tms}->getTileWidth($level);
}

=begin nd
Function: getCacheImageHeight

Returns the pyramid's image's pixel height, for a given level.

Parameters (list):
    level - string - Level ID
=cut
sub getCacheImageHeight {
    my $this = shift;
    my $level = shift;

    return $this->{image_height} * $this->{tms}->getTileHeight($level);
}

# Function: getLevel
sub getLevel {
    my $this = shift;
    my $level = shift;
    return $this->{levels}->{$level};
}


####################################################################################################
#                                Group: Storage getters                                            #
####################################################################################################

# Function: getStorageType
sub getStorageType {
    my $this = shift;
    return $this->{storage_type};
}

### FILE

# Function: getDataDir
sub getDataDir {
    my $this = shift;    
    return File::Spec->catfile($this->{data_path}, $this->{name});
}

# Function: getDirDepth
sub getDirDepth {
    my $this = shift;
    return $this->{dir_depth};
}

### S3

# Function: getDataBucket
sub getDataBucket {
    my $this = shift;    
    return $this->{data_bucket};
}

### CEPH

# Function: getDataPool
sub getDataPool {
    my $this = shift;    
    return $this->{data_pool};
}

# Function: getClusterName
sub getClusterName {
    my $this = shift;    
    return $this->{cluster_name};
}

# Function: getUserName
sub getUserName {
    my $this = shift;    
    return $this->{user_name};
}

# Function: getConfFile
sub getConfFile {
    my $this = shift;    
    return $this->{conf_file};
}

1;
__END__
