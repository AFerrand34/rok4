#!/usr/bin/env perl
# Copyright © (2011) Institut national de l'information
#                    géographique et forestière 
# 
# Géoportail SAV <geop_services@geoportail.fr>
# 
# This software is a computer program whose purpose is to publish geographic
# data using OGC WMS and WMTS protocol.
# 
# This software is governed by the CeCILL-C license under French law and
# abiding by the rules of distribution of free software.  You can  use, 
# modify and/ or redistribute the software under the terms of the CeCILL-C
# license as circulated by CEA, CNRS and INRIA at the following URL
# "http://www.cecill.info". 
# 
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability. 
# 
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security. 
# 
# The fact that you are presently reading this means that you have had
# 
# knowledge of the CeCILL-C license and that you accept its terms.

use warnings;
use strict;

use POSIX qw(locale_h);

use Getopt::Long;
use Pod::Usage;

use Data::Dumper;
use Math::BigFloat;
use File::Spec::Link;
use File::Basename;
use File::Spec;
use File::Path;
use Cwd;

use Log::Log4perl qw(:easy);
use XML::LibXML;

# My search module
use FindBin qw($Bin);
use lib "$Bin/../lib/perl5";

# My module
use BE4::TileMatrixSet;
use BE4::Pixel;
use BE4::NoData;
use BE4::Level;

################################################################################
# Constantes
use constant TRUE  => 1;
use constant FALSE => 0;
use constant RESULT_TEST => "if [ \$? != 0 ] ; then echo \$0 : Erreur a la ligne \$(( \$LINENO - 1)) >&2 ; exit 1; fi\n";

################################################################################
# Pas de bufferisation des sorties.
$|=1;

################################################################################
# Version
my $VERSION = '@VERSION_TEXT@';

################################################################################
# Global
my $STRPYRTMPLT   = <<"TPYR";
<?xml version='1.0' encoding='US-ASCII'?>
<Pyramid>
    <tileMatrixSet>__TMSNAME__</tileMatrixSet>
    <format>__FORMATIMG__</format>
    <channels>__CHANNEL__</channels>
    <nodataValue>__NODATAVALUE__</nodataValue>
    <interpolation>__INTERPOLATION__</interpolation>
    <photometric>__PHOTOMETRIC__</photometric>
<!-- __LEVELS__ -->
</Pyramid>
TPYR

################################################################################
#
# Title: joinCache
#
####################################################################################################
#                                              VARIABLES                                           #
####################################################################################################

# Group: variables

#
=begin nd
variable: %opts

Command options.

    * version
    * help
    * usage
    * properties
=cut
my %opts =
(
    "version"    => 0,
    "help"       => 0,
    "usage"      => 0,
    
    # Configuration
    "properties"  => undef, # file properties params (mandatory) !
);

#
=begin nd
variable: %this

All Parameters by section.
    * logger
    * pyramid
    * bboxes
    * composition
    * process

Perl objects to merge pyramids.
    * sourceByLevel
    * sourcePyramids
    * currentscript
    * streams
    * doneTiles
=cut
my %this =
(

    logger        => undef,
    pyramid       => undef,
    bboxes        => undef,
    composition   => undef,
    process       => undef,

    sourceByLevel => {},
    sourcePyramids => {},

    currentscript => 0,
    streams => [],

    doneTiles => {},
);

#
=begin nd
variable: %CONF

Define allowed:
    * sections
    * merge methods
    * compressions
=cut
my %CONF = (
    sections => ['pyramid','process','composition','logger','bboxes'],
    merge_method => ['replace','transparency','multiply'],
    compression => ['raw','jpg','png','lzw','zip'],
);

#
=begin nd
variable: %SAMPLEFORMAT2CODE

To convert sample format from parameter to code
=cut
my %SAMPLEFORMAT2CODE = (
    uint => "INT",
    float => "FLOAT"
);

####################################################################################################
#                                                MAIN                                              #
####################################################################################################

# Group: main

#
=begin nd
method: main

Main method

See Also:
    <_init>, <_config>, <_validate>, <openStreams>, <doIt>, <closeStreams>, <writePyr>
=cut
sub main {
    printf("JoinCache : version [%s]\n",$VERSION);
    # message
    my $message = undef;

    $message = "BEGIN";
    printf STDOUT "%s\n", $message;

    # initialization
    ALWAYS("> Initialization");
    if (! main::_init()) {
        $message = "ERROR INITIALIZATION !";
        printf STDERR "%s\n", $message;
        exit 1;
    }

    # configuration
    ALWAYS("> Configuration");
    if (! main::_config()) {
        $message = "ERROR CONFIGURATION !";
        printf STDERR "%s\n", $message;
        exit 2;
    }

    # execution
    ALWAYS("> Validation");
    if (! main::_validate()) {
        $message = "ERROR VALIDATION !";
        printf STDERR "%s\n", $message;
        exit 3;
    }

    # ouverture des flux
    ALWAYS("> Open streams to scripts");
    if (! main::openStreams()) {
        $message = "ERROR OPEN STREAMS !";
        printf STDERR "%s\n", $message;
        exit 4;
    }    

    # execution
    ALWAYS("> Execution");
    if (! main::doIt()) {
        $message = "ERROR EXECUTION !";
        printf STDERR "%s\n", $message;
        exit 5;
    }

    # fermeture des flux
    ALWAYS("> Close streams to scripts");
    if (! main::closeStreams()) {
        $message = "ERROR CLOSE STREAMS !";
        printf STDERR "%s\n", $message;
        exit 6;
    }  

    # writting pyramid's configuration file
    ALWAYS("> Write pyramid's descriptor");
    if (! main::writePyr()) {
        $message = "ERROR WRITE PYRAMID DESCRIPTOR !";
        printf STDERR "%s\n", $message;
        exit 7;
    }

    $message = "END";
    printf STDOUT "%s\n", $message;
}

#
=begin nd
method: _init

Check options and initialize the logger
=cut
sub _init {

    ALWAYS(">>> Check Configuration ...");

    # init Getopt
    local $ENV{POSIXLY_CORRECT} = 1;

    Getopt::Long::config qw(
        default
        no_autoabbrev
        no_getopt_compat
        require_order
        bundling
        no_ignorecase
        permute
    );

    # init Options
    GetOptions(
        "help|h"        => sub { pod2usage( -sections => "NAME|DESCRIPTION|SYNOPSIS|OPTIONS", -exitval=> 0, -verbose => 99); },
        "version|v"     => sub { printf "%s version %s", basename($0), $VERSION; exit 0; },
        "usage"         => sub { pod2usage( -sections => "SYNOPSIS", -exitval=> 0, -verbose => 99); },
        #
        "properties|conf=s"  => \$opts{properties},

    ) or pod2usage( -message => "Usage inapproprié", -verbose => 1);


    # logger by default at runtime
    Log::Log4perl->easy_init( {
        level => $WARN,
        layout => '[%M](%L): %m%n'}
    );

    # check Options

    # properties : mandatory !
    if (! defined $opts{properties}) {
        ERROR("Option 'properties' not defined !");
        return FALSE;
    }

    my $fproperties = File::Spec->rel2abs($opts{properties});

    if (! -d dirname($fproperties)) {
        ERROR(sprintf "File path doesn't exist ('%s') !", dirname($fproperties));
        return FALSE;
    }

    if (! -f $fproperties) {
        ERROR(sprintf "File name doesn't exist ('%s') !", basename($fproperties));
        return FALSE;
    }

    $opts{properties} = $fproperties;

    return TRUE;
}

####################################################################################################
#                                     CONFIGURATION LOADER                                         #
####################################################################################################  

# Group: configuration loader

#
=begin nd
method: _config

Load all parameters from the configuration file.

See Also:
    <_read>, <checkParams>
=cut
sub _config {
  
    ALWAYS(">>> Load Properties ...");

    my $fprop = $opts{properties};

    if (! defined $fprop) {
        ERROR ("The file path is required to read configuration !");
        return FALSE;
    }
    
    if (! -f $fprop) {
        ERROR (sprintf "Configuration file doesn't exist : %s",$fprop);
        return FALSE;
    }

    return FALSE if (! main::_read($fprop));
    return FALSE if (! main::checkParams($fprop));

    return TRUE;

}

#
=begin nd
method: _read

Read line by line (order is important), no library is used.

Parameter:
    filepath - Configuration file to read.

See Also:
    <is_ConfSection>, <readComposition>
=cut
sub _read {
    my $filepath = shift;

    TRACE;

    if (! open CFGF, "<", $filepath ){
        ERROR(sprintf "Cannot open configurations' file %s.",$filepath);
        return FALSE;
    }

    my $currentSection = undef;

    while( defined( my $l = <CFGF> ) ) {
        chomp $l;
        $l =~ s/\s+//g; # we remove all spaces
        $l =~ s/;\S*//; # we remove comments
        
        next if ($l eq '');

        if ($l =~ m/^\[(\w*)\]$/) {
            $l =~ s/[\[\]]//g;

            if (! main::is_ConfSection($l)) {
                ERROR ("Invalid section's name");
                return FALSE;
            }
            $currentSection = $l;
            next;
        }

        if (! defined $currentSection) {
            ERROR (sprintf "A property must always be in a section (%s)",$l);
            return FALSE;
        }

        my @prop = split(/=/,$l,-1);
        if (scalar @prop != 2 || $prop[0] eq '' || $prop[1] eq '') {
            ERROR (sprintf "A line is invalid (%s). Must be prop = val",$l);
            return FALSE;   
        }

        if ($currentSection ne 'composition') {
            if (exists $this{$currentSection}->{$prop[0]}) {
                ERROR (sprintf "A property is defined twice in the configuration : section %s, parmaeter %s",
                    $currentSection,$prop[0]);
                return FALSE; 
            }
            $this{$currentSection}->{$prop[0]} = $prop[1];
        } else {
            if (! main::readComposition($prop[0],$prop[1])) {
                ERROR (sprintf "Cannot read a composition !");
                return FALSE;
            }
        }
        
    }

    close CFGF;

    return TRUE;
}

#
=begin nd
method: readComposition

Read a 'composition' section line. Determine sources by level and calculate priorities.

Parameters:
    prop - composition's name: levelId.bboxId
    val - composition's value: pyrPath1,pyrPath2,pyrPath3
=cut
sub readComposition {
    my $prop = shift;
    my $val = shift;

    TRACE;

    my ($levelId,$bboxId) = split(/\./,$prop,-1);

    if ($levelId eq '' || $bboxId eq '') {
        ERROR (sprintf "Cannot define a level id and a bbox id (%s). Must be levelId.bboxId",$prop);
        return FALSE;
    }

    my @pyrs = split(/,/,$val,-1);

    foreach my $pyr (@pyrs) {
        if ($pyr eq '') {
            ERROR (sprintf "Invalid list of pyramids (%s). Must be /path/pyr1.pyr,/path/pyr2.pyr",$val);
            return FALSE;
        }
        if (! -f $pyr) {
            ERROR (sprintf "A referenced pyramid's file doesn't exist : %s",$pyr);
            return FALSE;
        }

        my $priority = 1;
        if (exists $this{sourceByLevel}->{$levelId}) {
            $this{sourceByLevel}->{$levelId} += 1;
            $priority = $this{sourceByLevel}->{$levelId};
        } else {
            $this{sourceByLevel}->{$levelId} = 1;
        }

        $this{composition}->{$levelId}->{$priority} = {
            bbox => $bboxId,
            pyr => $pyr,
        };

        if (! exists $this{sourcePyramids}->{$pyr}) {
            # we have a new source pyramid, but not yet information about
            $this{sourcePyramids}->{$pyr} = undef;
        }

    }

    return TRUE;

}

#
=begin nd
method: is_ConfSection

Check section's name

Parameter:
    section - section's name

Possible values: 'pyramid','process','composition','logger','bboxes'.
=cut
sub is_ConfSection {
    my $section = shift;

    TRACE;

    return FALSE if (! defined $section);

    foreach (@{$CONF{sections}}) {
        return TRUE if ($section eq $_);
    }
    ERROR (sprintf "Unknown 'section' (%s) !",$section);
    return FALSE;
}



#
=begin nd
method: checkParams

Check is basic: sections have not to be empty
=cut
sub checkParams {

    ###################
    # check parameters

    my $pyramid      = $this{pyramid};        
    my $logger       = $this{logger};         
    my $composition  = $this{composition};    
    my $bboxes       = $this{bboxes};         
    my $process      = $this{process};    

    # pyramid
    if (! defined $pyramid) {
        ERROR ("Section [pyramid] can not be null !");
        return FALSE;
    }

    # composition
    if (! defined $composition) {
        ERROR ("Section [composition] can not be null !");
        return FALSE;
    }

    # bboxes
    if (! defined $bboxes) {
        ERROR ("Section [bboxes] can not be null !");
        return FALSE;
    }

    # process
    if (! defined $process) {
        ERROR ("Section [process] can not be null !");
        return FALSE;
    }

    # logger
    if (defined $logger) {
        my @args;

        my $layout= '[%C][%M](%L): %m%n';
        my $level = $logger->{log_level};

        my $out   = "STDOUT";
        $level = "WARN"   if (! defined $level);

        if ($level =~ /(ALL|DEBUG)/) {
            $layout = '[%C][%M](%L): %m%n';
        }

        # add the param logger by default (user settings !)
        push @args, {
            file   => $out,
            level  => $level,
            layout => $layout,
        };

        Log::Log4perl->easy_init(@args);
    }

    return TRUE;
}

####################################################################################################
#                                         STREAM METHODS                                           #
####################################################################################################  

# Group: stream methods

#
=begin nd
method: openStreams

Open one stream by script and write header. They stay opened to write commands directly in files (not store in memory).
=cut
sub openStreams {
    TRACE;

    for (my $i = 0; $i < $this{process}->{job_number}; $i++) {
        my $scriptId = sprintf "SCRIPT_%s",$i+1;

        my $scriptName     = join('.',$scriptId,'sh');
        my $scriptFilePath = File::Spec->catfile($this{process}->{path_shell}, $scriptName);

        if (! -d dirname($scriptFilePath)) {
            my $dir = dirname($scriptFilePath);
            DEBUG (sprintf "Create the script directory'%s' !", $dir);
            eval { mkpath([$dir]); };
            if ($@) {
                ERROR(sprintf "Can not create the script directory '%s' : %s !", $dir , $@);
                return FALSE;
            }
        }
        
        DEBUG(sprintf "Open stream to %s",$scriptFilePath);
        my $SCRIPT;
        if ( ! (open $SCRIPT,">", $scriptFilePath)) {
            ERROR(sprintf "Can not save the script '%s' into directory '%s' !.", $scriptName, dirname($scriptFilePath));
            return FALSE;
        }
        
        my $header = sprintf ("# Environment variables\n");
        $header   .= sprintf ("SCRIPT_ID=\"%s\"\n", $scriptId);
        $header   .= sprintf ("TMP_DIR=\"%s\"\n",
            File::Spec->catdir($this{process}->{path_temp},$this{pyramid}->{pyr_name},$scriptId));
        $header   .= sprintf ("PYR_DIR=\"%s\"\n", $this{pyramid}->{pyr_data_path});
        $header   .= "\n";
        
        $header .= "# Work directory creation\n";
        $header .= "if [ ! -d \"\${TMP_DIR}\" ] ; then mkdir -p \${TMP_DIR} ; fi\n\n";
        
        printf $SCRIPT "%s", $header;
        
        push @{$this{streams}},$SCRIPT;
        
    }

    return TRUE;

}

#
=begin nd
method: closeStreams

Close all streams to scripts.
=cut
sub closeStreams {

    TRACE;

    for (my $i = 0; $i < $this{process}->{job_number}; $i++) {
        my $scriptId = sprintf "SCRIPT_%s",$i+1;
        DEBUG(sprintf "Close stream %s",$scriptId);
        close $this{streams}[$i];
    }

    return TRUE;

}

#
=begin nd
method: printInScript

Writes commands in the current script. Round robin method is used to fill scripts.

Parameter:
    code - code to write in the current script.

=cut
sub printInScript {
    my $code = shift;

    TRACE;

    my $stream = $this{streams}[$this{currentscript}];
    printf ($stream "%s", $code);

    $this{currentscript} = ($this{currentscript}+1)%($this{process}->{job_number});

}

####################################################################################################
#                                       VALIDATION METHODS                                         #
####################################################################################################  

# Group: validation method

#
=begin nd
method: _validate

Validates all components, checks consistency.

See Also:
    <validateMergedPyramid>, <validateBboxes>, <validateSourcePyramids>, <validateComposition>
=cut
sub _validate {

    ##################

    ALWAYS(">>> Validate merge pyramid ...");

    if (! main::validateMergedPyramid()) {
        ERROR ("Merged pyramid is not valid !");
        return FALSE;
    }

    ##################
    # load bounding boxes
    ALWAYS(">>> Validate bounding boxes ...");

    if (! main::validateBboxes()) {
        ERROR ("Some bboxes are not valid !");
        return FALSE;
    }

    DEBUG(sprintf "BBOXES : %s",Dumper($this{bboxes}));

    ##################

    ALWAYS(">>> Validate source pyramids ...");

    if (! main::validateSourcePyramids()) {
        ERROR ("Some source pyramids are not valid !");
        return FALSE;
    }

    DEBUG(sprintf "SOURCE PYRAMIDS : %s",Dumper($this{sourcePyramids}));

    ALWAYS(">>> Validate composition");
    if (! main::validateComposition()) {
        ERROR ("Cannot validate composition !");
        return FALSE;
    }

    DEBUG(sprintf "COMPOSITION : %s",Dumper($this{composition}));

    return TRUE;
    
}

#
=begin nd
method: validateComposition

Validates each source in the composition.
    - levelId have to be in the TMS
    - bboxId have to be defined in the 'bboxes' section (and is interpreted)
    - used level have to be present in the pyramid

We store too pyramid's format (phtomoetric, samples per pixel...).

See also:
    <calculateBbox>
=cut
sub validateComposition {

    TRACE();

    my $composition = $this{composition};
    my $bboxes = $this{bboxes};
    my $tms = $this{pyramid}->{tms};

    while( my ($levelId,$sources) = each(%$composition) ) {
        if (! defined $tms->getTileMatrix($levelId)) {
            ERROR (sprintf "A level id (%s) from the configuration file is not in the TMS !",$levelId);
            return FALSE;
        }

        while( my ($priority,$source) = each(%$sources) ) {
            if (! exists $bboxes->{$source->{bbox}}) {
                ERROR (sprintf "A bbox id (%s) from the composition is not define in the 'bboxes' section !",
                    $source->{bbox});
                return FALSE;
            }
            # we replace .pyr path by the data directory for this level
            if (! exists $this{sourcePyramids}->{$source->{pyr}}->{$levelId}) {
                ERROR (sprintf "The pyramid '%s' is used for the level %s but has not it !",
                    $source->{pyr},$levelId);
                return FALSE;
            }

            if (exists $this{sourcePyramids}->{$source->{pyr}}->{isCompatible}) {
                $source->{isCompatible} = TRUE;
            } else {
                $source->{format} = $this{sourcePyramids}->{$source->{pyr}}->{format};
                $source->{photometric} = $this{sourcePyramids}->{$source->{pyr}}->{photometric};
                $source->{samplesperpixel} = $this{sourcePyramids}->{$source->{pyr}}->{samplesperpixel};
            }

            $source->{pyr} = $this{sourcePyramids}->{$source->{pyr}}->{$levelId};
            my @bboxArray = main::calculateBbox($levelId,$source->{bbox});
            $source->{bbox} = undef;
            @{$source->{bbox}} = @bboxArray;
        }
    
    }

    return TRUE;
}

#
=begin nd
method: calculateBbox

We have source's bbox in ground coordinates. We calculate indices for a given level.

Parameters:
    levelId - level for which we want to calculate bbox's indices
    bboxId - bbox whose we want to calculate indices
=cut
sub calculateBbox {
    my $levelId = shift;
    my $bboxId = shift;

    TRACE();

    my @bboxArray = @{$this{bboxes}->{$bboxId}} ;

    my $tm  = $this{pyramid}->{tms}->getTileMatrix($levelId);

    my $Res = Math::BigFloat->new($tm->getResolution());
    my $imgGroundWidth = $tm->getTileWidth() * $this{pyramid}->{tilesPerWidth} * $Res;
    my $imgGroundHeight = $tm->getTileHeight() * $this{pyramid}->{tilesPerHeight} * $Res;

    my $iMin=int(($bboxArray[0] - $tm->getTopLeftCornerX()) / $imgGroundWidth);   
    my $iMax=int(($bboxArray[2] - $tm->getTopLeftCornerX()) / $imgGroundWidth);   
    my $jMin=int(($tm->getTopLeftCornerY() - $bboxArray[3]) / $imgGroundHeight); 
    my $jMax=int(($tm->getTopLeftCornerY() - $bboxArray[1]) / $imgGroundHeight);

    $bboxArray[0] = $iMin;
    $bboxArray[1] = $jMin;
    $bboxArray[2] = $iMax;
    $bboxArray[3] = $jMax;

    return @bboxArray;

    return TRUE;
}

#
=begin nd
method: validateBboxes

For each bbox, we parse string to store values in array and we control consistency (min < max).
=cut
sub validateBboxes {
    TRACE();

    my $bboxes = $this{bboxes};

    while( my ($bboxId,$bbox) = each(%$bboxes) ) {
        if ($bbox !~ m/([+-]?\d+(\.\d+)?),([+-]?\d+(\.\d+)?),([+-]?\d+(\.\d+)?),([+-]?\d+(\.\d+)?)/) {
            ERROR (sprintf "The bbox with id '%s' is not valid (%s).
                Must be 'xmin,ymin,xmax,ymax', to decimal format.",$bboxId,$bbox);
            return FALSE;
        }

        my @bboxArray = split(/,/,$bbox,-1);
        if (!($bboxArray[0] < $bboxArray[2] && $bboxArray[1] < $bboxArray[3])) {
            ERROR (sprintf "The bbox with id '%s' is not valid (%s). Max is not greater than min !",$bboxId,$bbox);
            return FALSE;
        }
        
        # we replace the string bbox by the array bbox
        $bboxes->{$bboxId} = undef;
        @{$bboxes->{$bboxId}} = @bboxArray;
    }

    return TRUE;
}

#
=begin nd
method: validateMergedPyramid

Checks final pyramid's paramters (compression, TMS, merge method...)

See also:
    <is_Compression>, <is_MergeMethod>
=cut
sub validateMergedPyramid {

    TRACE();

    ##################
    # load TMS

    if (!( exists $this{pyramid}->{tms_path} &&  exists $this{pyramid}->{tms_name})) {
        ERROR ("TMS path information are missing in the configuration file !");
        return FALSE;
    }
    my $objTMS = BE4::TileMatrixSet->new(File::Spec->catfile($this{pyramid}->{tms_path},$this{pyramid}->{tms_name}));

    if (! defined $objTMS) {
        ERROR (sprintf "Cannot load the TMS %s !",$this{pyramid}->{tms_name});
        return FALSE;
    } else {
        delete($this{pyramid}->{tms_path});
        delete($this{pyramid}->{tms_name});
    }

    $this{pyramid}->{tms} = $objTMS;

    if (! exists $this{pyramid}->{merge_method}) {
        ERROR ("'merge_method' must be given in the configuration file !");
        return FALSE;
    } elsif (! main::is_MergeMethod($this{pyramid}->{merge_method})) {
        ERROR ("Invalid 'merge_method' !");
        return FALSE;
    }

    if (! exists $this{pyramid}->{compression}) {
        ERROR ("'compression' must be given in the configuration file !");
        return FALSE;
    } elsif (! main::is_Compression($this{pyramid}->{compression})) {
        ERROR ("Invalid 'compression' !");
        return FALSE;
    }

    my $objPixel = BE4::Pixel->new({
        photometric => $this{pyramid}->{photometric},
        sampleformat => $this{pyramid}->{sampleformat},
        bitspersample => $this{pyramid}->{bitspersample},
        samplesperpixel => $this{pyramid}->{samplesperpixel}
    });
    if (! defined $objPixel) {
        ERROR (sprintf "Cannot create the Pixel object !");
        return FALSE;
    } else {
        if ($this{pyramid}->{sampleformat} ne 'uint') {
            ERROR (sprintf "Just 'uint' sampleformat is handled (not '%s')",$this{pyramid}->{sampleformat});
            return FALSE;
        }
        # formatCode : TIFF_[COMPRESSION]_[SAMPLEFORMAT][BITSPERSAMPLE]
        $this{pyramid}->{format} = sprintf "TIFF_%s_%s%s",
            uc $this{pyramid}->{compression},
            $SAMPLEFORMAT2CODE{$this{pyramid}->{sampleformat}},
            $this{pyramid}->{bitspersample};

        delete($this{pyramid}->{photometric});
        delete($this{pyramid}->{sampleformat});
        delete($this{pyramid}->{bitspersample});
        delete($this{pyramid}->{samplesperpixel});
    }
    $this{pyramid}->{pixel} = $objPixel;

    return TRUE;

}

#
=begin nd
method: is_MergeMethod

Check merge method value.

Parameter:
    mergeMethod - merge method value

Possible values: 'replace','transparency','multiply'.
=cut
sub is_MergeMethod {
    my $mergeMethod = shift;

    TRACE;

    return FALSE if (! defined $mergeMethod);

    foreach (@{$CONF{merge_method}}) {
        return TRUE if ($mergeMethod eq $_);
    }
    ERROR (sprintf "Unknown 'merge_method' (%s) !",$mergeMethod);
    return FALSE;
}

#
=begin nd
method: is_Compression

Check compression value.

Parameter:
    compression - compression value

Possible values: 'raw','jpg','png','lzw','zip'.
=cut
sub is_Compression {
    my $compression = shift;

    TRACE;

    return FALSE if (! defined $compression);

    foreach (@{$CONF{compression}}) {
        return TRUE if ($compression eq $_);
    }
    ERROR (sprintf "Unknown 'compression' (%s) !",$compression);
    return FALSE;
}

#
=begin nd
method: validateSourcePyramids

For each pyramid in composition, we store and control attributes, reading pyramid's descriptor. TMS, tiles per width, tiles per height and directory depth have to be the same for every one.

See alse:
    <is_Compatible>
=cut
sub validateSourcePyramids {

    TRACE();

    my $tms;
    my $dirDepth;
    my $tilesPerWidth;
    my $tilesPerHeight;

    foreach my $pyr (keys %{$this{sourcePyramids}}) {
        my ($volume,$directories,$file) = File::Spec->splitpath($pyr);

        # read xml pyramid
        my $parser  = XML::LibXML->new();
        my $xmltree =  eval { $parser->parse_file($pyr); };

        if (! defined ($xmltree) || $@) {
            ERROR (sprintf "Can not read the XML file Pyramid : %s !", $@);
            return FALSE;
        }

        my $root = $xmltree->getDocumentElement;

        # FORMAT
        my $tagformat = $root->findnodes('format')->to_literal;
        if ($tagformat eq '') {
            ERROR (sprintf "Can not determine parameter 'format' in the XML file Pyramid (%s) !",
                $pyr);
            return FALSE;
        }
        # Format have to be 8-bits unsigned integer
        if ($tagformat !~ m/_INT8/) {
            ERROR("Use pyramids have to be in 8-bits unsigned integer (format = TIFF_XXX_INT8");
            return FALSE;
        }
        
        # SAMPLES PER PIXEL
        my $tagchannels = $root->findnodes('channels')->to_literal;
        if ($tagchannels eq '') {
            ERROR (sprintf "Can not determine parameter 'channels' in the XML file Pyramid (%s) !",
                $pyr);
            return FALSE;
        }

        # TMS
        my $tagTMS = $root->findnodes('tileMatrixSet')->to_literal;
        if ($tagTMS eq '') {
            ERROR (sprintf "Can not determine parameter 'tileMatrixSet' in the XML file Pyramid (%s) !",
                $pyr);
            return FALSE;
        }
        if (defined $tms && $tagTMS ne $tms) {
            ERROR (sprintf "The TMS in the pyramid '%s' is different from %s (%s) !",
                $pyr,$tms,$tagTMS);
            return FALSE;
        }
        $tms = $tagTMS if (! defined $tms);
        if ($tms ne $this{pyramid}->{tms}->{name}) {
            ERROR (sprintf "The TMS in the pyramid '%s' is different from the TMS in the configuration %s (%s) !",
                $pyr,$this{pyramid}->{tms}->{name},$tms);
            return FALSE;
        }

        # PHOTOMETRIC
        my $tagphotometric = $root->findnodes('photometric')->to_literal;
        if ($tagphotometric eq '') {
            ERROR (sprintf "Can not determine parameter 'photometric' in the XML file Pyramid (%s) !",
                $pyr);
            return FALSE;
        }

        # LEVELS
        my @levels = $root->getElementsByTagName('level');
        
        # read tilesPerWidth and tilesPerHeight, using a level
        my $level = $levels[0];
        my $tagtilesPerWidth = $level->findvalue('tilesPerWidth');
        my $tagtilesPerHeight = $level->findvalue('tilesPerHeight');

        if (defined $tilesPerHeight && 
            ($tagtilesPerHeight ne $tilesPerHeight || $tagtilesPerWidth ne $tilesPerWidth)) {
            ERROR (sprintf "The tile size in the pyramid '%s' is different from %s,%s (%s,%s) !",
                $pyr,$tilesPerHeight,$tilesPerWidth,$tagtilesPerHeight,$tagtilesPerWidth);
            return FALSE;
        }
        $tilesPerHeight = $tagtilesPerHeight if (! defined $tilesPerHeight);
        $tilesPerWidth = $tagtilesPerWidth if (! defined $tilesPerWidth);

        # read dirDepth, using a level
        my $tagdepth = $level->findvalue('pathDepth');

        if (defined $dirDepth && $tagdepth ne $dirDepth) {
            ERROR (sprintf "The depth in the pyramid '%s' is different from %s (%s) !",$pyr,$dirDepth,$tagdepth);
            return FALSE;
        }
        $dirDepth = $tagdepth if (! defined $dirDepth);

        foreach my $v (@levels) {
            my $levelId = $v->findvalue('tileMatrix');
            my $baseDir = $v->findvalue('baseDir');
            $this{sourcePyramids}->{$pyr}->{$levelId} = File::Spec->rel2abs($baseDir,$volume.$directories);
        }

        if (main::is_Compatible($tagformat,$tagchannels)) {
            $this{sourcePyramids}->{$pyr}->{isCompatible} = TRUE;
        } else {
            $this{sourcePyramids}->{$pyr}->{format} = $tagformat;
            $this{sourcePyramids}->{$pyr}->{samplesperpixel} = $tagchannels;
            $this{sourcePyramids}->{$pyr}->{photometric} = $tagphotometric;
        }

    }

    # we save merged pyramid's attributes
    $this{pyramid}->{dirDepth} = $dirDepth;
    $this{pyramid}->{tilesPerWidth} = $tilesPerWidth;
    $this{pyramid}->{tilesPerHeight} = $tilesPerHeight;

    return TRUE;
}

#
=begin nd
method: is_Compatible

A pyramid is compatible with the final cache if format and sample per pixel are the same
=cut
sub is_Compatible {
    my $format = shift;
    my $samplesperpixel = shift;

    TRACE;

    return ($format eq $this{pyramid}->{format} && $samplesperpixel eq $this{pyramid}->{pixel}->{samplesperpixel});
}

####################################################################################################
#                                        PROCESS METHODS                                           #
####################################################################################################  

# Group: process method

#
=begin nd
method: doIt

Reads each image from each source pyramids which is in the bbox and writes it in the final cache, according the merge method.

See also:
    <getCacheNameOfImage>, <searchTile>, <treatTile>
=cut
sub doIt {

    TRACE();

    my $composition = $this{composition};
    my $bboxes = $this{bboxes};
    my $tms = $this{pyramid}->{tms};

    while( my ($levelId,$sources) = each(%$composition) ) {
        INFO(sprintf "Level %s",$levelId);

        my $priority = 1;
        my $baseImage = sprintf "%s/%s/%s/%s",
                        $this{pyramid}->{pyr_data_path},$this{pyramid}->{pyr_name},
                        $this{pyramid}->{image_dir},$levelId;
        my $baseNodata = sprintf "%s/%s/%s/%s",
                        $this{pyramid}->{pyr_data_path},$this{pyramid}->{pyr_name},
                        $this{pyramid}->{nodata_dir},$levelId;
        my ($IMIN,$JMIN,$IMAX,$JMAX);

        while( exists $sources->{$priority}) {
            my $source = $sources->{$priority};
            INFO(sprintf "Priority %s : pyramid %s",$priority,$source->{pyr});
            my ($imin,$jmin,$imax,$jmax) = @{$source->{bbox}};

            for (my $i = $imin; $i <= $imax; $i++) {
                for (my $j = $jmin; $j <= $jmax; $j++) {
                    if (exists $this{doneTiles}->{$i."_".$j}) {
                        #Tile have been already treated (treatment written in a script)
                        next;
                    }

                    my $imagePath = main::getCacheNameOfImage($i,$j);
                    my $sourceImage = $source->{pyr}.$imagePath;
                    if (! -f $sourceImage) {
                        # no data source
                        next;
                    }

                    # we update extrems tiles
                    if (! defined $IMIN || $i < $IMIN) {$IMIN = $i;}
                    if (! defined $JMIN || $j < $JMIN) {$JMIN = $j;}
                    if (! defined $IMAX || $i > $IMAX) {$IMAX = $i;}
                    if (! defined $JMAX || $j > $JMAX) {$JMAX = $j;}

                    my $finaleImage = $baseImage.$imagePath;
                    if (-f $finaleImage) {
                        #Tile already exists (it's a link)
                        next;
                    }

                    my @images;

                    if (exists $source->{isCompatible}) {
                        push @images,{img => $sourceImage,isCompatible => TRUE};
                    } else {
                        push @images,{img => $sourceImage,format => $source->{format},spp => $source->{samplesperpixel}};
                    }

                    if ($this{pyramid}->{merge_method} ne 'replace') {
                        my @others = main::searchTile($levelId,$priority+1,$i,$j,$imagePath,@images);
                        push @images,@others;
                    }

                    if (! main::treatTile($i,$j,$finaleImage,@images)) {
                        ERROR(sprintf "Cannot treat the image %s",$finaleImage);
                        return FALSE;                        
                    }
                }
            }
            $priority++;
        }

        my $levelOrder = $tms->getTileMatrixOrder($levelId);
        my $objLevel = BE4::Level->new({
            id                => $levelId,
            order             => $levelOrder,
            dir_image         => File::Spec->abs2rel($baseImage,$this{pyramid}->{pyr_desc_path}),
            dir_nodata        => File::Spec->abs2rel($baseNodata,$this{pyramid}->{pyr_desc_path}),
            dir_metadata      => undef,      # TODO !
            compress_metadata => undef,      # TODO !
            type_metadata     => undef,      # TODO !
            size              => [$this{pyramid}->{tilesPerWidth},$this{pyramid}->{tilesPerHeight}],
            dir_depth         => $this{pyramid}->{dirDepth},
            # WARN : I and J are IMAGE's indices and a Level object want TILE's indices
            limit             => [$JMIN*$this{pyramid}->{tilesPerHeight},($JMAX+1)*$this{pyramid}->{tilesPerHeight},$IMIN*$this{pyramid}->{tilesPerWidth},($IMAX+1)*$this{pyramid}->{tilesPerWidth}],
            is_in_pyramid     => 0
        });

        if (! defined $objLevel) {
            ERROR(sprintf "Can not create the pyramid Level object : '%s'", $levelId);
            return FALSE;
        }

        $this{pyramid}->{levels}->{$levelId} = $objLevel;

        delete $this{doneTiles};
    }

    return TRUE;

}

#
=begin nd
method: searchTile

Search a tile in source pyramids with a smaller priority

Parameters:
    levelId - level in which we serach tiles
    priority - source's priority from which we search tiles
    i,j - searched tile's indices
    imagePath - relative image path, from the image directory ("19/00/M4/12.tif")
=cut
sub searchTile {
    my $levelId = shift;
    my $priority = shift;
    my $i = shift;
    my $j = shift;
    my $imagePath = shift;

    TRACE();

    my $sources = $this{composition}->{$levelId};
    my @others;

    while( exists $sources->{$priority}) {
        my $source = $sources->{$priority};
        $priority++;
        my ($imin,$jmin,$imax,$jmax) = @{$source->{bbox}};

        if ($i < $imin || $i > $imax || $j < $jmin || $j > $jmax) {
            next;
        }

        my $sourceImage = $source->{pyr}.$imagePath;
        if (-f $sourceImage) {
            if (exists $source->{isCompatible}) {
                push @others,{img => $sourceImage,isCompatible => TRUE};
            } else {
                push @others,{img => $sourceImage,format => $source->{format},spp => $source->{samplesperpixel}};
            }
        }
    }  

    return @others;
  
}

#
=begin nd
method: treatTile

3 possibilities:
    - the image is present in just one pyramid or merge_method = replace, and is compatible with the final cache -> we write a symbolic link.
    - the image is present in just one pyramid or merge_method = replace, and is not compatible with the final cache -> we have just to convert image : compression and samples per pixel, commands are written in scripts.
    - the image is preent in seve(ral pyramids and merge method is not 'replace' -> we use tool 'overlayNtiff', commands are written in scripts.

Parameters:
    i,j - tile's indices to calculate
    finaleImage - absolute path of the final image
    images - array of absolute source images' paths
    
See also:
    <makeLink>, <transformImage>, <mergeImages>
=cut
sub treatTile {
    my $i = shift;
    my $j = shift;
    my $finaleImage = shift;
    my @images = @_;

    TRACE();

    if (scalar @images == 1 && exists $images[0]{isCompatible}) {
        if (! main::makeLink($finaleImage,$images[0]{img})) {
            ERROR(sprintf "Cannot create link between %s and %s",$finaleImage,$images[0]);
            return FALSE;
        }
        return TRUE
    }

    if (scalar @images == 1) {
        # We have just one source image, but it is not compatible with the final cache
        # We need to transform it.
        if (! main::transformImage($finaleImage,$images[0]{img},$images[0]{format},int($images[0]{spp}))) {
            ERROR(sprintf "Cannot transform the image %s",$images[0]{img});
            return FALSE;
        }
        $this{doneTiles}->{$i."_".$j} = TRUE;
        return TRUE;
    }

    main::mergeImages($finaleImage,@images);
    $this{doneTiles}->{$i."_".$j} = TRUE;
    return TRUE;

}

#
=begin nd
method: mergeImages

Write commands in the current script to merge n images according to the merge method. We use tiff2rgba to convert into work format and overlayNtiff to merge.

Parameters:
    finaleImage - absolute path of the final image
    images - array of absolute source images' paths
=cut
sub mergeImages {
    my $finaleImage = shift;
    my @images = @_;

    TRACE();

    my $code = '';

    my $dataPath = $this{pyramid}->{pyr_data_path};
    $finaleImage =~ s/$dataPath/\${PYR_DIR}/;

    # Pretreatment

    for (my $i = 0; $i < scalar @images; $i++) {
        if (exists $images[$i]{format} && $images[$i]{format} =~ m/PNG/) {
            $code .= sprintf "untile %s \${TMP_DIR}/\n%s",$images[$i]{img},RESULT_TEST;
            if ((exists $images[$i]{spp} && int($images[$i]{spp}) == 4) ||
                (exists $images[$i]{isCompatible} && int($this{pyramid}->{pixel}->{samplesperpixel}) == 4))
            {
                $code .= sprintf "montage -geometry 256x256 -tile 16x16 \${TMP_DIR}/*.png -depth 8 -background none -define tiff:rows-per-strip=4096 \${TMP_DIR}/PNG_untiled.tif\n%s",RESULT_TEST;
            } else {
                $code .= sprintf "montage -geometry 256x256 -tile 16x16 \${TMP_DIR}/*.png -depth 8 -define tiff:rows-per-strip=4096 \${TMP_DIR}/PNG_untiled.tif\n%s",RESULT_TEST;
            }
            $code .= sprintf "tiff2rgba -c none \${TMP_DIR}/PNG_untiled.tif \${TMP_DIR}/img%s.tif\n%s",$i,RESULT_TEST;
        } else {
            $code .= sprintf "tiff2rgba -c none %s \${TMP_DIR}/img%s.tif\n%s",$images[$i]{img},$i,RESULT_TEST;
        }
    }

    # Superposition
    $code .= sprintf "overlayNtiff -mode %s -transparent 255,255,255 -opaque 255,255,255 -channels %s -input ",
        $this{pyramid}->{merge_method},
        $this{pyramid}->{pixel}->{samplesperpixel};

    for (my $i = scalar @images - 1; $i >= 0; $i--) {
        $code .= sprintf "\${TMP_DIR}/img%s.tif ",$i;
    }

    $code .= " -output \${TMP_DIR}/result.tif \n";

    my $compression = $this{pyramid}->{compression};
    $compression = ($compression eq 'raw'?'none':$compression);

    # Final location writting
    $code .= sprintf "if [ -r \"%s\" ] ; then rm -f %s ; fi\n", $finaleImage, $finaleImage;
    $code .= sprintf "if [ ! -d \"%s\" ] ; then mkdir -p %s ; fi\n", dirname($finaleImage), dirname($finaleImage);

    $code .= sprintf "tiff2tile \${TMP_DIR}/result.tif -c %s -p %s -t 256 256 -b %s -a uint -s %s  %s\n%s",
        $compression,
        $this{pyramid}->{pixel}->{photometric},
        $this{pyramid}->{pixel}->{bitspersample},
        $this{pyramid}->{pixel}->{samplesperpixel},
        $finaleImage,RESULT_TEST;

    # Cleaning
    $code .= "rm -f \${TMP_DIR}/* \n\n";

    main::printInScript($code);
    
    return TRUE;
}

#
=begin nd
method: makeLink

Create a symbolic link in the final cache, to a source image.

Parameters:
    finaleImage - absolute path of the final image
    baseImage - absolute source image's path, to link
=cut
sub makeLink {
    my $finaleImage = shift;
    my $baseImage = shift;

    TRACE();

    #create folders
    my $finaldir = dirname($finaleImage);
    eval { mkpath([$finaldir]); };
    if ($@) {
        ERROR(sprintf "Can not create the cache directory '%s' : %s !",dirname($finaleImage), $@);
        return FALSE;
    }

    my $follow_relfile = undef;

    if (-f $baseImage && ! -l $baseImage) {
        $follow_relfile = File::Spec->abs2rel($baseImage,dirname($finaleImage));
    }
    elsif (-f $baseImage && -l $baseImage) {
        my $linked   = File::Spec::Link->linked($baseImage);
        my $realname = File::Spec::Link->full_resolve($linked);
        $follow_relfile = File::Spec->abs2rel($realname, dirname($finaleImage));
    } else {
        ERROR(sprintf "The tile '%s' is not a file or a link in '%s' !",basename($baseImage),dirname($baseImage));
        return FALSE;  
    }

    if (! defined $follow_relfile) {
        ERROR (sprintf "The link '%s' can not be resolved in '%s' ?",
                    basename($baseImage),
                    dirname($baseImage));
        return FALSE;
    }

    my $result = eval { symlink ($follow_relfile, $finaleImage); };
    if (! $result) {
        ERROR (sprintf "The tile '%s' can not be linked to '%s' (%s) ?",
                    $follow_relfile,$finaleImage,$!);
        return FALSE;
    }

    return TRUE;

}

#
=begin nd
method: makeLink

Write commands in the current script to transform an image in an other format, in the final cache. Can change, compression and samples per pixel.

Parameters:
    finaleImage - absolute path of the final image
    baseImage - absolute source image's path, to transform
    format - format of the source cache ('TIFF_PNG_INT8')
    spp - samples per pixel of the source cache
=cut
sub transformImage {
    my $finaleImage = shift;
    my $baseImage = shift;
    my $format = shift;
    my $spp = shift;

    TRACE();

    my $code = '';

    # Pretreatment

    if ($format =~ m/PNG/) {
        $code .= sprintf "untile %s \${TMP_DIR}/\n%s",$baseImage,RESULT_TEST;
        if ($spp == 4) {
            $code .= sprintf "montage -geometry 256x256 -tile 16x16 \${TMP_DIR}/*.png -depth 8 -background none -define tiff:rows-per-strip=4096 \${TMP_DIR}/img.tif\n%s",RESULT_TEST;
        } else {
            $code .= sprintf "montage -geometry 256x256 -tile 16x16 \${TMP_DIR}/*.png -depth 8 -define tiff:rows-per-strip=4096 \${TMP_DIR}/img.tif\n%s",RESULT_TEST;
        }
    } else {
        $code .= sprintf "tiffcp -r 4096 %s \${TMP_DIR}/img.tif\n%s",$baseImage,RESULT_TEST;
    }

    # We transform image with the samples per pixel of the final cache
    if ($this{pyramid}->{pixel}->{photometric} eq 'rgb' && int($this{pyramid}->{pixel}->{samplesperpixel}) == 3) {
        $code .= "tiff2rgba -c none -n \${TMP_DIR}/img.tif \${TMP_DIR}/transformedImg.tif\n";
    }
    elsif ($this{pyramid}->{pixel}->{photometric} eq 'rgb' && int($this{pyramid}->{pixel}->{samplesperpixel}) == 4) {
        $code .= "tiff2rgba -c none \${TMP_DIR}/img.tif \${TMP_DIR}/transformedImg.tif\n";
    }
    elsif ($this{pyramid}->{pixel}->{photometric} eq 'gray' && int($this{pyramid}->{pixel}->{samplesperpixel}) == 1) {
        $code .= "convert \${TMP_DIR}/img.tif -colors 256 -colorspace gray -depth 8 \${TMP_DIR}/transformedImg.tif\n";
    } else {
        ERROR (sprintf "Samplesperpixel (%s) and photometric (%d) not supported ",
            $this{pyramid}->{pixel}->{samplesperpixel},
            $this{pyramid}->{pixel}->{photometric});
        return FALSE;
    }

    my $compression = $this{pyramid}->{compression};
    $compression = ($compression eq 'raw'?'none':$compression);

    # Final location writting
    $code .= sprintf "if [ -r \"%s\" ] ; then rm -f %s ; fi\n", $finaleImage, $finaleImage;
    $code .= sprintf "if [ ! -d \"%s\" ] ; then mkdir -p %s ; fi\n", dirname($finaleImage), dirname($finaleImage);


    $code .= sprintf "tiff2tile \${TMP_DIR}/transformedImg.tif -c %s -p %s -t 256 256 -b %s -a uint -s %s  %s\n%s",
        $compression,
        $this{pyramid}->{pixel}->{photometric},
        $this{pyramid}->{pixel}->{bitspersample},
        $this{pyramid}->{pixel}->{samplesperpixel},
        $finaleImage,RESULT_TEST;

    # Cleaning
    $code .= " rm -f \${TMP_DIR}/* \n\n";

    main::printInScript($code);
    
    return TRUE;

}

####################################################################################################
#                                        WRITTING METHODS                                          #
####################################################################################################  

# Group: writting methods

#
=begin nd
method: writePyr

Export the Pyramid object to XML format, write the pyramid's descriptor ("pyr_desc_path/pyr_name_new.pyr"). Use Level XML export. Levels are written in descending order, from worst to best resolution.
=cut
sub writePyr {

    TRACE;
    
    # parsing template
    my $parser = XML::LibXML->new();

    my $doctpl = eval { $parser->parse_string($STRPYRTMPLT); };
    if (!defined($doctpl) || $@) {
        ERROR(sprintf "Can not parse template file of pyramid : %s !", $@);
        return FALSE;
    }
    my $strpyrtmplt = $doctpl->toString(0);
  
    #
    my $tmsname = $this{pyramid}->{tms}->getName();
    $strpyrtmplt =~ s/__TMSNAME__/$tmsname/;
    #
    my $formatimg = $this{pyramid}->{format}; # ie TIFF_RAW_INT8 !
    $strpyrtmplt  =~ s/__FORMATIMG__/$formatimg/;
    #  
    my $channel = $this{pyramid}->{pixel}->{samplesperpixel};
    $strpyrtmplt =~ s/__CHANNEL__/$channel/;
    #  
    my $nodata = BE4::NoData->new({
        value => undef, #default value will be set.
        pixel => $this{pyramid}->{pixel},
        nowhite => "false"
    });

    my $nodataValue = $nodata->getValue();
    $strpyrtmplt =~ s/__NODATAVALUE__/$nodataValue/;
    #  
    $strpyrtmplt =~ s/__INTERPOLATION__/bicubic/;
    #  
    my $photometric = $this{pyramid}->{pixel}->{photometric};
    $strpyrtmplt =~ s/__PHOTOMETRIC__/$photometric/;

    foreach my $objLevel (values %{$this{pyramid}->{levels}}) {
        my $levelXML = $objLevel->getLevelToXML();
        $strpyrtmplt =~ s/<!-- __LEVELS__ -->\n/$levelXML/;
        
        # Nodata tile creation
        my $nodataTilePath = File::Spec->catdir($this{pyramid}->{pyr_data_path},$objLevel->{dir_nodata},$objLevel->getID(),"nd.tif");

        my $width = $this{pyramid}->{tms}->getTileWidth($objLevel->{id});
        my $height = $this{pyramid}->{tms}->getTileHeight($objLevel->{id});
        
        if (! $nodata->createNodata($nodataTilePath,$width,$height,$this{pyramid}->{compression})) {
            ERROR (sprintf "Impossible to create the nodata tile for the level %i !",$objLevel->getID());
            return FALSE;
        }
    }
    #
    $strpyrtmplt =~ s/<!-- __LEVELS__ -->\n//;
    $strpyrtmplt =~ s/^$//g;
    $strpyrtmplt =~ s/^\n$//g;
    #
  
    my $filepyramid = File::Spec->catfile($this{pyramid}->{pyr_desc_path},$this{pyramid}->{pyr_name}.".pyr");

    if (-f $filepyramid) {
        ERROR(sprintf "File Pyramid ('%s') exist, can not overwrite it ! ", $filepyramid);
        return FALSE;
    }
    #
    my $PYRAMID;

    if (! open $PYRAMID, ">", $filepyramid) {
        ERROR("");
        return FALSE;
    }
    #
    printf $PYRAMID "%s", $strpyrtmplt;
    #
    close $PYRAMID;

    return TRUE;
}

####################################################################################################
#                                             TOOLS                                                #
####################################################################################################  

# Group: tools

#
=begin nd
method: getCacheNameOfImage

Return the image relative path, from the data directory (pyr_data_path/dir_image). Tile's indices are convert in base 36, and split to give the path.

Example:
    getCacheNameOfImage(4032,18217) returns "3E/42/01.tif"

Parameter:
    i,j - indices from which name is determined
=cut
sub getCacheNameOfImage {
    my $i     = shift; # X idx !
    my $j     = shift; # Y idx !

    my $ib36 = main::encodeIntToB36($i);
    my $jb36 = main::encodeIntToB36($j);

    my @icut = split (//, $ib36);
    my @jcut = split (//, $jb36);

    if (scalar(@icut) != scalar(@jcut)) {
        if (length ($ib36) > length ($jb36)) {
            $jb36 = "0"x(length ($ib36) - length ($jb36)).$jb36;
            @jcut = split (//, $jb36);
        } else {
            $ib36 = "0"x(length ($jb36) - length ($ib36)).$ib36;
            @icut = split (//, $ib36);
        }
    }

    my $padlength = $this{pyramid}->{dirDepth} + 1;
    my $size      = scalar(@icut);
    my $pos       = $size;
    my @l;

    for(my $i=0; $i<$padlength;$i++) {
        $pos--;
        push @l, $jcut[$pos];
        push @l, $icut[$pos];
        push @l, '/';
    }

    pop @l;

    if ($size>$padlength) {
        while ($pos) {
            $pos--;
            push @l, $jcut[$pos];
            push @l, $icut[$pos];
        }
    }

    my $imagePath = scalar reverse(@l);
    my $imagePathName = join('.', $imagePath, 'tif');

    return File::Spec->catfile('/'.$imagePathName); 
}

sub encodeIntToB36 {
    my $number= shift; # idx !

    my $padlength = $this{pyramid}->{dirDepth} + 1;

    my $b36 = "";
    $b36 = "000" if $number == 0;

    while ( $number ) {
        my $v = $number % 36;
        if($v <= 9) {
            $b36 .= $v;
        } else {
            $b36 .= chr(55 + $v); # Assume that 'A' is 65
        }
        $number = int $number / 36;
    }

    # fill with 0 !
    $b36 = "0"x($padlength - length $b36).reverse($b36);

    return $b36;
}

################################################################################

BEGIN {}
INIT {}

main;
exit 0;

END {}

################################################################################

1;
__END__

=head1 NAME

joinCache - create a pyramid from several, thanks to n triplets (composition)

A triplet = a level (ID in the TMS) + an extent (a bbox) + a list of pyramid's descriptor path

=head1 SYNOPSIS

    perl joinCache.pl --conf=path

=head1 DESCRIPTION

All used pyramids must have identical parameters : used TMS, sample format (uint), bits per sample (8). Resulting pyramid will have same attributes.

Others parameters are free (compression, samples per pixel) and have to be defined for the final cache.

Bounding boxes' SRS have to be the TMS' one.

=head1 JOINCACHE CONFIGURATION FILE

=head2 By section

=over 4

=head3 logger

=item log_level

Define importance level from which we print messages. From less to more important : DEBUG - INFO - WARN - ERROR - ALWAYS (WARN by default).

=head3 pyramid

=item pyr_name

Name of the new pyramid, used to name the descriptor, the cache's list, the data directory and the temporary directory.

Mandatory.

=item pyr_desc_path

Directory path, where to write the descriptor.

Mandatory.

=item pyr_data_path

Directory path, where to write the cache.

Mandatory.

=item compression

Possible values : raw, jpg, zip, lzw, png, pkb. png compression is not an official compression for tiff format (just readable by rok4).

Mandatory.

=item bitspersample

Possible value : 8.

Mandatory.

=item sampleformat

Possible value : uint.

Mandatory.

=item samplesperpixel

Possible values : 1, 3, 4.

Mandatory.

=item photometric

Possible values : gray, rgb. Have to be consistent with the samples per pixel. 1 -> gray and 3,4 -> rgb.

Mandatory.

=item dir_image, dir_nodata

Names of subdirectories in the cache, in F<pyr_data_path/pyr_name/>.

Default : IMAGE, NODATA.

=item tms_name

TMS file name, with extension .tms.

Mandatory.

=item tms_path

Directory, where to find the TMS file.

Mandatory.

=item merge_method

Method to use to overlay several images. Used by overlayNtiff.

Possible values : 'replace', 'transparency', 'multiply'.

Mandatory.

=head3 process

=item job_number

Number of split scripts. Round robin method is used to share jobs between splits.

Mandatory.

=item path_temp

Temporary directory path in which we create a directory named like the merged cache : temporary files are written in F<path_temp/pyr_name_new/>.

Mandatory.

=item path_shell

Directory path, to write scripts in. Scripts are named F<SCRIPT_1.sh>,F<SCRIPT_2.sh>... for all generation. That's why the path_shell must be specific to the generation (contains the name of the pyramid for example).

Mandatory.

=back

=head3 bboxes

Format : ID = xmin,ymin,xmax,ymax , ID is a basic string, without space and coordinates are in the TMS' SRS.

=head3 composition

Format : LevelID.BboxId = pyrPath1,pyrPath2 , BboxId have to be defined in 'bboxes' section, LevelId have to be present in the TMS and in used pyramids.

Order in 'composition' is important, a triplet will take precedence over the triplets for a same level.

=head2 Example.

    ;Commentaires
    
    [logger]
    log_level      = INFO
    
    [pyramid]
    pyr_name       = MERGE_PYRAMID
    pyr_desc_path  = /home/ign/JoinCache
    pyr_data_path  = /home/ign/JoinCache
    
    tms_path       = /home/ign/TMS
    tms_name       = LAMB93_10cm.tms
    
    image_dir      = IMAGE
    nodata_dir     = NODATA
    
    compression = jpg
    samplesperpixel = 3
    photometric = rgb
    bitspersample = 8
    sampleformat = uint
    
    merge_method   = multiply 
    
    [bboxes]
    PARIS = 535286,6747049,771666,6976667
    
    [process]
    path_shell  = /home/ign/JoinCache      ;Commentaires
    path_temp   = /home/ign/TMP
    job_number  = 4
    
    [composition]  
    
    16.PARIS = /home/ign/PYRAMIDS/PARCELLAIRE_PNG_LAMB93_PARIS_OUEST.pyr
    16.PARIS = /home/ign/PYRAMIDS/ORTHO_RAW_LAMB93_PARIS_OUEST.pyr
    
    19.PARIS = /home/ign/PYRAMIDS/PARCELLAIRE_PNG_LAMB93_PARIS_OUEST.pyr,/home/ign/PYRAMIDS/ORTHO_RAW_LAMB93_PARIS_OUEST.pyr

=head1 OPTIONS

=over 4

=item --help

=item --usage

=item --version

=item --conf=path

Path to file configuration of the pyramid. This option is mandatory !

=back

=head1 SEE ALSO

=head2 Intern libraries

=head3 POD documentation

=begin html

<ul>
<li><A HREF="./lib-BE4-TileMatrixSet.html">BE4::TileMatrixSet</A></li>
<li><A HREF="./lib-BE4-Level.html">BE4::Level</A></li>
<li><A HREF="./lib-BE4-NoData.html">BE4::NoData</A></li>
<li><A HREF="./lib-BE4-NoData.html">BE4::NoData</A></li>
</ul>

=end html

=head3 NaturalDocs

=begin html

<A HREF="../Natural/Html/index.html">Index</A>

=end html

=head2 Modules CPAN

POSIX qw(locale_h)

sigtrap qw(die normal-signals)

Getopt::Long

Pod::Usage

Log::Log4perl qw(get_logger)

Cwd qw(abs_path cwd chdir)

File::Spec

=head1 AUTHOR

Théo Satabin, E<lt>theo.satabin@ign.frE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2011 by Satabin Théo

This library is free software; you can redistribute it and/or modify it under the same terms as Perl itself, either Perl version 5.10.1 or, at your option, any later version of Perl 5 you may have available.

=cut
