#!/usr/bin/env perl
# Copyright © (2011) Institut national de l'information
#                    géographique et forestière
#
# Géoportail SAV <geop_services@geoportail.fr>
#
# This software is a computer program whose purpose is to publish geographic
# data using OGC WMS and WMTS protocol.
#
# This software is governed by the CeCILL-C license under French law and
# abiding by the rules of distribution of free software.  You can  use,
# modify and/ or redistribute the software under the terms of the CeCILL-C
# license as circulated by CEA, CNRS and INRIA at the following URL
# "http://www.cecill.info".
#
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability.
#
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or
# data to be ensured and,  more generally, to use and operate it in the
# same conditions as regards security.
#
# The fact that you are presently reading this means that you have had
#
# knowledge of the CeCILL-C license and that you accept its terms.

################################################################################

=begin nd
File: 4head.pl

Section: 4HEAD tool

Synopsis:
    (start code)
    4head.pl --pyr <FILE> --tmsdir <DIRECTORY> --reference-level <LEVEL ID> --top-level <LEVEL ID>
    (end code)
=cut

################################################################################

use warnings;
use strict;

use POSIX qw(locale_h);

# Module
use Log::Log4perl qw(:easy);
use Getopt::Long;
use Cwd;

# My search module
use FindBin qw($Bin);
use lib "$Bin/../lib/perl5";

# My module
use COMMON::PyramidRaster;
use COMMON::CheckUtils;
use FOURHEAD::Node;
use FOURHEAD::Shell;

################################################################################
# Constantes
use constant TRUE  => 1;
use constant FALSE => 0;

################################################################################
# Version
my $VERSION = '@VERSION_TEXT@';

=begin nd
Variable: options

Contains 4head call options :

    version - To obtain the command's version
    help - To obtain the command's help
    usage - To obtain the command's usage
    
    pyr - To precise the pyramid's descriptor file
    tmsdir - The directory with TMS
    tmp - The directory to use for temporary files
    reference-level - The level from which above levels are regenerated
    top-level - The level to which above levels are regenerated
    
=cut
my %options =
(
    "version"    => 0,
    "help"       => 0,
    "usage"      => 0,

    # Mandatory
    "pyr"  => undef,
    "tmsdir"  => undef,
    "tmp"  => undef,
    "reference-level"  => undef,
    "top-level"  => undef
);

####################################################################################################
#                                         Group: Functions                                         #
####################################################################################################

=begin nd
Function: main

Main method.

See Also:
    <init>, <doIt>
=cut
sub main {
    printf("4HEAD : version [%s]\n",$VERSION);

    print STDOUT "BEGIN\n";

    # initialization
    ALWAYS("> Initialization");
    if (! main::init()) {
        print STDERR "ERROR INITIALIZATION !\n";
        exit 1;
    }

    # execution
    ALWAYS("> Execution");
    if (! main::doIt()) {
        print STDERR "ERROR EXECUTION !\n";
        exit 5;
    }

    print STDOUT "END\n";
}

=begin nd
Function: init

Checks and stores options, initializes the default logger. Checks TMS directory and the pyramid's descriptor file.
=cut
sub init {

    # init Getopt
    local $ENV{POSIXLY_CORRECT} = 1;

    Getopt::Long::config qw(
        default
        no_autoabbrev
        no_getopt_compat
        require_order
        bundling
        no_ignorecase
        permute
    );

    # init Options
    GetOptions(
        "help|h" => sub {
            printf "4head.pl --pyr <FILE> --tmsdir <DIRECTORY> --reference-level <LEVEL ID> --top-level <LEVEL ID> --tmp <DIRECTORY>\n" ;
            exit 0;
        },
        "version|v" => sub { exit 0; },
        "usage" => sub {
            printf "4head.pl --pyr <FILE> --tmsdir <DIRECTORY> --reference-level <LEVEL ID> --top-level <LEVEL ID> --tmp <DIRECTORY\n" ;
            exit 0;
        },
        
        "pyr=s" => \$options{pyr},
        "tmsdir=s" => \$options{tmsdir},
        "tmp=s" => \$options{tmp},
        "reference-level=s" => \$options{"reference-level"},
        "top-level=s" => \$options{"top-level"},
    ) or do {
        printf "Unappropriate usage\n";
        printf "4head.pl --pyr <FILE> --tmsdir <DIRECTORY> --reference-level <LEVEL ID> --top-level <LEVEL ID> --tmp <DIRECTORY\n";
        exit -1;
    };
    
    # logger by default at runtime
    Log::Log4perl->easy_init({
        level => "INFO",
        layout => '%5p : %m (%M) %n'
    });
    
    ############# TMSDIR

    if (! defined $options{tmsdir} || $options{tmsdir} eq "") {
        ERROR("Option 'tmsdir' not defined !");
        return FALSE;
    }

    if (! -d $options{tmsdir}) {
        ERROR(sprintf "TMS directory does not exist : %s", $options{tmsdir});
        return FALSE;
    }

    ############# TMP

    if (! defined $options{tmp} || $options{tmp} eq "") {
        ERROR("Option 'tmsdir' not defined !");
        return FALSE;
    }

    if (! -d $options{tmp}) {
        ERROR(sprintf "Temporary directory does not exist : %s", $options{tmp});
        return FALSE;
    }

    ############# PYR

    if (! defined $options{pyr} || $options{pyr} eq "") {
        ERROR("Option 'pyr' not defined !");
        return FALSE;
    }

    my $pyrFile = File::Spec->rel2abs($options{pyr});

    if (! -f $pyrFile) {
        ERROR(sprintf "Pyramid's descriptor file does not exist : %s", $pyrFile);
        return FALSE;
    }

    $options{pyr} = COMMON::PyramidRaster->new("DESCRIPTOR", $pyrFile);
    if (! defined $options{pyr}) {
        ERROR(sprintf "Cannot load raster pyramid from descriptor %s", $pyrFile);
        return FALSE;
    }

    if (! $options{pyr}->bindTileMatrixSet($options{tmsdir})) {
        ERROR("Cannot bind TMS to pyramid !");
        return FALSE;
    }

    if (! $options{pyr}->getTileMatrixSet()->isQTree()) {
        ERROR("Only QTree TMS is handled by 4head");
        return FALSE;
    }

    ############# REFERENCE LEVEL

    if (! defined $options{"reference-level"} || $options{"reference-level"} eq "") {
        ERROR("Option 'reference-level' not defined !");
        return FALSE;
    }

    if (! defined $options{pyr}->getLevel($options{"reference-level"})) {
        ERROR("Provided reference level is not a level ID of the pyramid");
        return FALSE;
    }

    $options{"reference-level"} = $options{pyr}->getTileMatrixSet()->getTileMatrix($options{"reference-level"});

    ############# TOP LEVEL

    if (! defined $options{"top-level"} || $options{"top-level"} eq "") {
        ERROR("Option 'top-level' not defined !");
        return FALSE;
    }
    
    if (! defined $options{pyr}->getTileMatrixSet()->getTileMatrix($options{"top-level"})) {
        ERROR("Provided top level is not a level ID of the pyramid's TMS");
        return FALSE;
    }

    $options{"top-level"} = $options{pyr}->getTileMatrixSet()->getTileMatrix($options{"top-level"});

    if ($options{"top-level"}->getOrder() <= $options{"reference-level"}->getOrder()) {
        ERROR("Top level have to be strictly above the reference level");
        return FALSE;
    }

    return TRUE;
}

####################################################################################################
#                                 Group: Process methods                                           #
####################################################################################################

=begin nd
Function: doIt

Use classes :
    - <ProxyStorage::remove>
=cut
sub doIt {

    if (! $options{pyr}->loadList()) {
        ERROR("Cannot cache content list of the pyramid");
        return FALSE;
    }

    my $tms = $options{pyr}->getTileMatrixSet();

    my $referenceOrder = $options{"reference-level"}->getOrder();
    my $referenceID = $options{"reference-level"}->getID();

    my $topOrder = $options{"top-level"}->getOrder();
    my $topID = $options{"top-level"}->getID();

    # On part des dalles présentes dans la pyramide au niveau de référence
    my $referenceLevelSlabs = $options{pyr}->getLevelSlabs($referenceID);
    if (! exists $referenceLevelSlabs->{IMAGE}) {
        WARN("No slab in level $referenceID in the pyramid");
        return TRUE;
    }

    my @referenceNodes = ();

    # Nodification des dalles du niveau de référence

    foreach my $slab (keys(%{$referenceLevelSlabs->{IMAGE}})) {

        if ($options{pyr}->ownMasks() && ! exists $referenceLevelSlabs->{MASK}->{$slab}) {
            ERROR("Pyramid have to own masks and a data slab have no associated mask according the list");
            return FALSE;
        }
        my ($COL, $ROW) = split(/_/, $slab);

        push(
            @referenceNodes,
            FOURHEAD::Node->new({
                col => $COL,
                row => $ROW,
                level => $referenceID
            })
        );
    }

    # Création de l'arbre des noeuds (dalles) à regénérer

    my $regeneratedNodes = {};
    foreach my $referenceNode (@referenceNodes) {

        my $childNode = $referenceNode;

        for (my $levelOrder = $referenceOrder + 1; $levelOrder <= $topOrder; $levelOrder++) {
            my $levelID = $tms->getIDfromOrder($levelOrder);

            my $col = int($childNode->getCol() / 2);
            my $row = int($childNode->getRow() / 2);

            my $stop = FALSE;
            if (exists $regeneratedNodes->{$levelID}->{"${col}_$row"}) {
                $stop = TRUE;
            } else {
                $regeneratedNodes->{$levelID}->{"${col}_$row"} = FOURHEAD::Node->new({
                    col => $col,
                    row => $row,
                    level => $levelID
                });
            }

            if (! $regeneratedNodes->{$levelID}->{"${col}_$row"}->addSourceNode($childNode)) {
                ERROR("Conflict building the tree");
                return FALSE;
            }

            if ($stop) {last;}

            $childNode = $regeneratedNodes->{$levelID}->{"${col}_$row"};
        }


    }

    # Écriture dans le script des commandes de regénération des dalles

    my $file = "script.sh";
    my $STREAM;
    open($STREAM, ">$file") or die "Cannot open '$file' to write in it";

    printf $STREAM "%s\n", FOURHEAD::Shell::getScriptInitialization($options{pyr}, $options{tmp});    

    foreach my $topIndice (keys(%{$regeneratedNodes->{$topID}})) {

        my $topNode = $regeneratedNodes->{$topID}->{$topIndice};

        $topNode->writeCode($options{pyr}, $STREAM);
    }

    close($STREAM);

    # Écrire la nouvelle liste

    if (! $options{pyr}->flushCachedList()) {
        ERROR("Cannot write the cached list");
        return FALSE;
    }

    return TRUE;
}

################################################################################

BEGIN {}
INIT {}

main;
exit 0;

END {}

################################################################################

1;
__END__

=begin nd
Section: Details

Group: Command's options

    --help - Display the link to the technic documentation.

    --usage - Display the link to the technic documentation.

    --version - Display the tool version.
=cut
