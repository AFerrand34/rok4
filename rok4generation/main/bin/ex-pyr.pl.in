#!/usr/bin/env perl
# Copyright © (2011) Institut national de l'information
#                    géographique et forestière 
# 
# Géoportail SAV <geop_services@geoportail.fr>
# 
# This software is a computer program whose purpose is to publish geographic
# data using OGC WMS and WMTS protocol.
# 
# This software is governed by the CeCILL-C license under French law and
# abiding by the rules of distribution of free software.  You can  use, 
# modify and/ or redistribute the software under the terms of the CeCILL-C
# license as circulated by CEA, CNRS and INRIA at the following URL
# "http://www.cecill.info". 
# 
# As a counterpart to the access to the source code and  rights to copy,
# modify and redistribute granted by the license, users are provided only
# with a limited warranty  and the software's author,  the holder of the
# economic rights,  and the successive licensors  have only  limited
# liability. 
# 
# In this respect, the user's attention is drawn to the risks associated
# with loading,  using,  modifying and/or developing or reproducing the
# software by the user in light of its specific status of free software,
# that may mean  that it is complicated to manipulate,  and  that  also
# therefore means  that it is reserved for developers  and  experienced
# professionals having in-depth computer knowledge. Users are therefore
# encouraged to load and test the software's suitability as regards their
# requirements in conditions enabling the security of their systems and/or 
# data to be ensured and,  more generally, to use and operate it in the 
# same conditions as regards security. 
# 
# The fact that you are presently reading this means that you have had
# 
# knowledge of the CeCILL-C license and that you accept its terms.

################################################################################

=begin nd
File: ex-pyr.pl
=cut

################################################################################

use warnings;
use strict;

use POSIX qw(locale_h);

use Getopt::Long;
use Pod::Usage;

use Data::Dumper;
#local $Data::Dumper::Maxdepth = 1;

use File::Basename;
use File::Spec;
use File::Path;
use Cwd;

use Log::Log4perl qw(:easy);

# My search module
use FindBin qw($Bin);
use lib "$Bin/../lib/perl5";

# My module
use COMMON::CheckUtils;
use COMMON::PyramidRaster;
use EXPYR::PropertiesLoader;

################################################################################
# Constantes
use constant TRUE  => 1;
use constant FALSE => 0;

################################################################################
# no output buffering.
$|=1;

####################################################################################################
#                                       Group: Variables                                           #
####################################################################################################

# Variable: version
my $VERSION = '@VERSION_TEXT@';

=begin nd
Variable: options

Contains exPyr call options :

    version - To obtain the command's version
    help - To obtain the command's help
    usage - To obtain the command's usage
    properties - Configuration file
=cut
my %options =
(
    "version"    => 0,
    "help"       => 0,
    "usage"      => 0,
    
    # Configuration
    "properties"  => undef, # datasource and output properties file (mandatory) !
);

=begin nd
Variable: this

=cut
my %this =
(
    properties => undef,
    configuration => undef,
    params => {
        datasource    => undef,
        pyramid       => undef
    }
);

####################################################################################################
#                                         Group: Functions                                         #
####################################################################################################
=begin nd
Function: main

Main method.

See Also:
    <init>, <config>, <doIt>
=cut
sub main {
    printf("EX-PYR: version [%s]\n",$VERSION);

    # initialization
    ALWAYS("> Initialization");
    if (! main::init()) {
    print STDERR "ERROR INITIALIZATION !\n";
    exit 1;
    }

    print STDOUT "BEGIN\n";

    # configuration
    ALWAYS("> Configuration");
    if (! main::config()) {
    print STDERR "ERROR CONFIGURATION !\n";
    exit 2;
    }

    # execution
    ALWAYS("> Execution");
    if (! main::doIt()) {
    print STDERR "ERROR EXECUTION !\n";
    exit 3;
    }

    print STDOUT "END\n";
}

=begin nd
Function: init

Checks options and initializes the default logger.
=cut
sub init {
  
    # init Getopt
    local $ENV{POSIXLY_CORRECT} = 1;
    
    Getopt::Long::config qw(
        default
        no_autoabbrev
        no_getopt_compat
        require_order
        bundling
        no_ignorecase
        permute
    );

    # init Options
    GetOptions(
        "help|h" => sub {
            printf "See documentation here: \n" ;
            exit 0;
        },
        "version|v" => sub { exit 0; },
        "usage" => sub {
            printf "See documentation here: \n" ;
            exit 0;
        },
        
        "properties|conf=s" => \$options{properties},       
    ) or do {
        printf "Unappropriate usage\n";
        printf "See documentation here: \n" ;
        exit -1;
    };
  
    # logger by default at runtime
    Log::Log4perl->easy_init({
        level => "INFO",
        layout => '%5p : %m (%M) %n'
    });

    # We make path absolute

    # properties : mandatory !
    if (! defined $options{properties} || $options{properties} eq "") {
        ERROR("Option 'properties' not defined !");
        return FALSE;
    }
    my $fproperties = File::Spec->rel2abs($options{properties});
    $options{properties} = $fproperties;
    
    return TRUE;
}

=begin nd
Function: config

Loads properties file.

See Also:
    <checkParams>
=cut
sub config {

    ###################
    ALWAYS(">>> Load Properties ...");
    
    my $fprop = $options{properties};
    my $objProp = EXPYR::PropertiesLoader->new($fprop);
    
    if (! defined $objProp) {
        ERROR("Can not load properties !");
        return FALSE;
    }

    my $properties = $objProp->getAllProperties();

    $this{params}->{pyramid} = $properties->{pyramid};
    $this{params}->{datasource} = $properties->{datasource};

    # logger
    if (defined $properties->{logger}) {
    
        my @args;
        
        my $layout= '%5p : %m (%M) %n';
        my $level = $properties->{logger}->{log_level};
        my $out   = sprintf (">>%s", File::Spec->catfile($properties->{logger}->{log_path}, $properties->{logger}->{log_file}))
            if (! COMMON::CheckUtils::isEmpty($properties->{logger}->{log_path}) && ! COMMON::CheckUtils::isEmpty($properties->{logger}->{log_file}));
        
        $out   = "STDOUT" if (! defined $out);
        $level = "WARN"   if (! defined $level);
        
        if ($level =~ /(ALL|DEBUG)/) {
            $layout = '%5p : %m (%M) %n';
        }
        
        # add the param logger by default (user settings !)
        push @args, {
            file   => $out,
            level  => $level,
            layout => $layout,
        };
        
        if ($out ne "STDOUT") {
            # add the param logger to the STDOUT
            push @args, {
                file   => "STDOUT",
                level  => $level,
                layout => $layout,
            },
        }
        Log::Log4perl->easy_init(@args); 
    }

    return TRUE;
}

sub doIt {

    my @levels = keys(%{$this{params}->{datasource}});

    # On récupère la première pyramide pour configurer celle de sortie
    my $first = $levels[0];
    my $tmpSrcPyr = COMMON::PyramidRaster->new("DESCRIPTOR", $this{params}->{datasource}->{$first}->{desc_file});
    if (! defined $tmpSrcPyr) {
        ERROR("Can not load a source pyramid (level $first) to obtain reference parameters !");
        return FALSE;
    }

    if (! $tmpSrcPyr->bindTileMatrixSet($this{params}->{pyramid}->{tms_path})) {
        ERROR("Can not bind the TMS to reference source pyramid (level $first)");
        return FALSE;
    }

    my $tpw = $tmpSrcPyr->getTilesPerWidth();
    my $tph = $tmpSrcPyr->getTilesPerHeight();

    my $dstPyramid = COMMON::PyramidRaster->new("VALUES", {
        pyr_data_path => $this{params}->{pyramid}->{pyr_data_path},
        pyr_desc_path => $this{params}->{pyramid}->{pyr_desc_path},
        pyr_name_new => $this{params}->{pyramid}->{pyr_name},

        tms_name => $tmpSrcPyr->getTileMatrixSet()->getName(),

        image_width => $tpw,
        image_height => $tph,
        dir_depth => $tmpSrcPyr->getDirDepth(),

        interpolation => $tmpSrcPyr->getImageSpec()->getInterpolation(),
        color => $tmpSrcPyr->getNodata()->getValue(),

        compression => $tmpSrcPyr->getImageSpec()->getCompression(),
        photometric => $tmpSrcPyr->getImageSpec()->getPixel()->getPhotometric(),
        sampleformat => $tmpSrcPyr->getImageSpec()->getPixel()->getSampleFormat(),
        bitspersample => $tmpSrcPyr->getImageSpec()->getPixel()->getBitsPerSample(),
        samplesperpixel => $tmpSrcPyr->getImageSpec()->getPixel()->getSamplesPerPixel()
    });

    if (! defined $dstPyramid) {
        ERROR("Cannot create the output pyramid for extraction");
        return FALSE;
    }

    if (! $dstPyramid->bindTileMatrixSet($this{params}->{pyramid}->{tms_path})) {
        ERROR("Can not bind the TMS to output pyramid");
        return FALSE;
    }

    my $dstStorageType = $dstPyramid->getStorageType();

    # Si le descripteur de pyramide existe déjà, on aura fait tout le travail pour planter lors du writeDescriptor
    # Petit check avant tout ça
    if (-e $dstPyramid->getDescriptorFile()) {
        ERROR("Cannot owerwrite the already existing output pyramid descriptor");
        return FALSE;
    }

    # Chargement et vérification des sources
    my $loadedSources = {};

    while (my ($level, $source) = each (%{$this{params}->{datasource}}) ) {

        INFO("Load source for level $level:");
        INFO("\t Source pyramid: ".$source->{desc_file});
        INFO("\t Extent: ".$source->{extent});

        # Load the source pyramid and check usability
        $loadedSources->{$level}->{pyramid} = COMMON::PyramidRaster->new("DESCRIPTOR", $source->{desc_file});
        if (! defined $loadedSources->{$level}->{pyramid}) {
            ERROR("Can not load the source pyramid (level $level)");
            return FALSE;
        }

        if (! $loadedSources->{$level}->{pyramid}->bindTileMatrixSet($this{params}->{pyramid}->{tms_path})) {
            ERROR("Can not bind the TMS to source pyramid (level $level)");
            return FALSE;
        }

        if ($dstPyramid->checkCompatibility($loadedSources->{$level}->{pyramid}) != 2 ) {
            ERROR("Source pyramid for level $level is not equals to output pyramid");
            return FALSE;
        }

        if (! defined $loadedSources->{$level}->{pyramid}->getLevel($level)) {
            ERROR("No level $level in the source pyramid, next level");
            return FALSE;
        }
        $loadedSources->{$level}->{pyramid} = $loadedSources->{$level}->{pyramid}->getLevel($level);


        # Ce niveau est créé dans la pyramide de sortie, même s'il est potentiellement vide
        if (! $dstPyramid->addLevel($level)) {
            ERROR("Cannot add level $level in the output pyramid");
            return FALSE;
        }

        $source->{extent} =~ s/ //;
        my @limits = split (/,/, $source->{extent},-1);

        if (scalar @limits == 4) {
            # user supplied a BBOX
            $loadedSources->{$level}->{extent} = COMMON::ProxyGDAL::geometryFromString("BBOX", $source->{extent});
            if (! defined $loadedSources->{$level}->{extent}) {
                ERROR(sprintf "Cannot create a OGR geometry from the bbox %s", $source->{extent});
                return FALSE ;
            }

        }
        else {
            # user supplied a file which contains bounding polygon
            $loadedSources->{$level}->{extent} = COMMON::ProxyGDAL::geometryFromFile($source->{extent});
            if (! defined $loadedSources->{$level}->{extent}) {
                ERROR(sprintf "Cannot create a OGR geometry from the file %s", $source->{extent});
                return FALSE ;
            }
        }
    }

    # Construction de la pyamide de sortie
    while (my ($level, $source) = each (%{$loadedSources}) ) {
        INFO("Level $level in progress...");

        my $srcLevel = $source->{pyramid};
        my $srcStorageType = $srcLevel->getStorageType();

        my $dstLevel = $dstPyramid->getLevel($level);

        my $extent = $source->{extent};
        my $bboxes = COMMON::ProxyGDAL::getBboxes($extent);
        if (! defined $bboxes) {
            ERROR("Cannot calculate bboxes from the extent for level $level");
            return FALSE;
        }

        my @tileBbox = (undef, undef, undef, undef);
        foreach my $bb (@{$bboxes}) {

            my ($rowMin, $rowMax, $colMin, $colMax) = $srcLevel->bboxToSlabIndices(@{$bb});
            
            for (my $col = $colMin; $col <= $colMax; $col++) {
                for (my $row = $rowMin; $row <= $rowMax; $row++) {

                    my $srcSlabPath = $srcLevel->getSlabPath("IMAGE", $col, $row, TRUE);
                    if (! defined $srcSlabPath) {
                        ERROR("Cannot calculate path of slab for $level - $col - $row");
                        return FALSE;
                    }

                    if (! COMMON::ProxyStorage::isPresent($srcStorageType, $srcSlabPath)) {
                        next;
                    }

                    $dstLevel->updateLimitsFromSlab($col, $row);

                    my $dstSlabPath = $dstLevel->getSlabPath("IMAGE", $col, $row, TRUE);

                    if ($this{params}->{pyramid}->{extract_mode} eq "slink") {
                        if (! defined COMMON::ProxyStorage::symLink($srcStorageType, $srcSlabPath, $dstStorageType, $dstSlabPath)) {
                            ERROR("The ancestor slab '$srcSlabPath' cannot be referenced by sym link in the new pyramid");
                            return FALSE;
                        }
                    }
                    elsif ($this{params}->{pyramid}->{extract_mode} eq "hlink") {
                        if (! COMMON::ProxyStorage::hardLink($srcStorageType, $srcSlabPath, $dstStorageType, $dstSlabPath)) {
                            ERROR("The ancestor slab '$srcSlabPath' cannot be referenced by hard link in the new pyramid");
                            return FALSE;
                        }
                    }
                    elsif ($this{params}->{pyramid}->{extract_mode} eq "copy") {
                        if (! COMMON::ProxyStorage::copy($srcStorageType, $srcSlabPath, $dstStorageType, $dstSlabPath)) {
                            ERROR("The ancestor slab '$srcSlabPath' cannot be referenced by copy in the new pyramid");
                            return FALSE;
                        }
                    }
                }
            }
        }
    }

    if (! $dstPyramid->writeDescriptor()) {
        ERROR("Cannot write the output pyramid descriptor");
        return FALSE;
    }

    return TRUE;
}

################################################################################

BEGIN {}

main();
exit 0;

END {}

################################################################################

1;
__END__
